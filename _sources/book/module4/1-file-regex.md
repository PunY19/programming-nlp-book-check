# การประมวลผลข้อมูลจากไฟล์

ข้อมูลที่เราต้องการนำมาประมวลผลมักจะถูกจัดเก็บในรูปของไฟล์ เมื่อเราได้ไฟล์มาแล้วเราจะต้องเขียนโปรแกรมเพื่อเปิดไฟล์ขึ้นมา และทำความสะอาดข้อมูล (เช่น นำส่วนที่ไม่ใช่ข้อมูลจริง ๆ ออกไป หรือนำส่วนที่ไม่ใช่ข้อความออกไป) จากนั้นนำมาตัดคำ หรือใช้เครื่องมือการประมวลผลภาษาอื่น ๆ มาช่วย 

ในบทนี้เราจะเรียนรู้วิธีการเปิดไฟล์ และเขียนข้อมูลลงไฟล์ รวมถึงการใช้ regular expression ในการทำความสะอาดข้อมูล และดึงเฉพาะส่วนของข้อมูลที่เราต้องการทำไปวิเคราะห์ต่อไป 

## ไฟล์ 

ไฟล์สามารถถูกแบ่งออกได้เป็น 2 ประเภท

1. ไฟล์ไบนารี (binary file) เป็นไฟล์ที่เราไม่สามารถเปิดอ่านเป็นตัวหนังสือได้ ข้อมูลถูกจัดเก็บรหัสประเภทอื่น ที่จะต้องใช้โปรแกรมเฉพาะเจาะจงในการเปิดอ่านและประมวลผล เช่น ไฟล์ภาพ ไฟล์เพลง ไฟล์ .docx ซึ่งต้องใช้โปรแกรม Microsoft Word ในการเปิดประมวลผล หรือ .xlsx ซึ่งต้องใช้โปรแกรม Microsoft Excel ในการเปิดประมวลผล ไฟล์เหล่านี้มีไลบรารีภาษาไพธอนที่สามารถใช้เปิดเพื่อนำข้อมูลมาประมวลผลได้เช่นกัน 

2. ไฟล์ที่มนุษย์อ่านได้ (human-readable file) เป็นไฟล์ที่เก็บข้อความไว้สามารถใช้ IDE ในการเปิดอ่านได้โดยตรง ไฟล์เหล่านี้เป็นไฟล์ที่ไม่ได้เก็บอะไรไว้เลยนอกเหนือจากข้อความอย่างเดียว ในบทนี้เราจะรับมือกับไฟล์ประเภทนี้เพียงอย่างเดียว ตัวอย่างเช่น .html .js .csv .json 

ไฟล์ทั้งสองแบบมักจะมีนามสกุลของไฟล์ (file extension) เพื่อบ่งบอกว่าควรจะเปิดขึ้นมาใช้ได้อย่างไร เช่น .docx .xlsx .png เป็นต้น แต่ที่จริงแล้วเราสามารถตั้งนามสกุลไฟล์เป็นอะไรก็ได้ตามแต่ใจเรา แต่ถ้าไฟล์เป็นข้อความดิบล้วน ๆ เรามักจะตั้งว่าเป็น .txt 

ทั้งนี้การตั้งชื่อและสกุลของไฟล์นั้นไม่มีผลต่อตัวข้อมูลที่เก็บในไฟล์ใด ๆ ทั้งสิ้น แต่อาจจะทำให้เกิดความสับสน ถ้าเราจะตั้งสกุลของไฟล์ที่เก็บข้อความเป็น .mytext ก็สามารถทำได้และไม่ได้มีผลต่อข้อความที่เก็บอยู่ในไฟล์ แต่ก็จะไม่เป็นมาตรฐาน เมื่อส่งไฟล์ต่อให้คนอื่น ก็จะไม่ทราบแน่ชัดว่าไฟล์นั้นเก็บอะไรไว้อยู่ จะต้องเปิดด้วยวิธีใด หรือจะตั้งหลอกว่าเป็น .docx ก็ได้เช่นกัน แต่ว่าผู้ที่นำไฟล์ไปใช้ต่อก็อาจจะนำไปใช้ผิดวิธี พอเปิดด้วย Microsoft Word ก็อาจจะไม่ได้ หรือไม่ได้ผลตามที่ควรจะเป็น

ในบทนี้เราจะเรียนรู้คำสั่งที่ใช้ในการเปิดไฟล์โดยทั่วไป แต่จะเน้นไปที่ไฟล์ข้อความ (text file) เท่านั้นเพราะเป็นระบบที่ใช้ในการเก็บข้อมูลที่เป็นข้อความ (text data) อย่างเป็นสากล

## การะบุพาธ

พาธ (path) หรือชื่อพาธ (pathname) เป็นสตริงที่ไว้ระบุที่อยู่ของไฟล์ที่อยู่บนเครื่องของเรา เพื่อที่เราจะได้เขียนคำสั่งได้ถูกต้องว่าไฟล์ที่เราต้องการจะเปิดนั้นอยู่ที่ไหนบนเครื่อง หรือไฟล์ที่เราต้องการจะสร้างนั้นมีชื่อว่าอะไรอยู่ไหน เพราะว่าไฟล์ต่าง ๆ ถูกเก็บอยู่ในโฟลเดอร์ (folder) ซึ่งในโฟลเดอร์นั้นอาจจะมีโฟลเดอร์อื่น ๆ ซ้อนกันอยู่ เราสามารถเปรียบเทียบการจัดเก็บไฟล์กับการจัดเรียงเอกสารในตู้เก็บเอกสาร โดยที่แต่ละโฟลเดอร์ในระบบไฟล์ทำหน้าที่เหมือนกับลิ้นชักในตู้เอกสาร เมื่อเราต้องการเข้าถึงไฟล์ที่ต้องการ เราต้องระบุเส้นทางที่ถูกต้องจากโฟลเดอร์หลักไปยังโฟลเดอร์ย่อยจนถึงไฟล์ที่ต้องการ


### พาธเต็ม 

พาธเต็ม (full path หรือ absolute path) คือการเขียนพาธแบบเต็ม ๆ ประกอบไปด้วย 3 ส่วนสำหรับ Windows และ 2 ส่วนสำหรับระบบปฏิบัติการ (Operating system: OS) MacOS และ Linux
1. (Windows เท่านั้น) ชื่อไดรฟ์ตามด้วยเครื่องหมาย : 
2. ชื่อโฟลเดอร์และโฟลเดอร์ย่อย ๆ คั่นด้วยเครื่องหมาย \ สำหรับ Windows และ / สำหรับ OS อื่น ๆ
3. ชื่อไฟล์ 

ตัวอย่าง (Windows)
| พาธเต็ม | ไดรฟ์ | โฟลเดอร์ | ชื่อไฟล์
|-----------|------|---------|--------
`C:\Downloads\data.zip` | C | `\Downloads` | `data.zip`
`C:\Documents\Prog NLP\example.ipynb` | C | `\Documents\Prog NLP` | `example.ipynb`

ตัวอย่าง (MacOS)
| พาธเต็ม | โฟลเดอร์ | ชื่อไฟล์
|-----------|---------|--------
`/Users/te/Downloads/data.zip` | `/Users/te/Downloads` | `data.zip`
`/Users/te/Prog NLP/example.ipynb` | `/Users/te/Prog NLP` | `example.ipynb`

### พาธสัมพัทธ์ 

การระบุพาธเต็มค่อนข้างยืดยาว พิมพ์แล้วมีโอกาสผิดสูง พาธสัมพัทธ์ (relative path) เป็นทางเลือกที่สะดวกกว่าเพราะว่าไม่จำเป็นต้องระบุพาธเต็ม ๆ พาธสัมพัทธ์จะใช้พาธของโฟลเดอร์ที่เรารันโค้ดมาต่อกันกับพาธสัมพัทธ์เพื่อให้กลายเป็นพาธแบบเต็ม เช่น ถ้าเรารันโค้ดที่โฟลเดอร์  `/Users/te/Prog NLP` และสั่งให้เปิดไฟล์ที่พาธสัมพัทธ์ `data/raw_text.zip` จะถูกแปลงให้กลายเป็น `/Users/te/Prog NLP/data/raw_text.zip` โดยอัตโนมัติ 

นอกจากนั้นเรายังสามารถระบุให้ถอยลงไปหนึ่งโฟลเดอร์หรือหลาย ๆ โฟลเดอร์ได้โดยการใช้ `..` เช่น ถ้าเรารันโค้ดที่โฟลเดอร์  `/Users/te/Prog NLP` 

| พาธสัมพัทธ์ | ถูกแปลงเป็นพาธเต็ม |
|-----------|---------|
|`../data/raw_text.zip`| `/Users/te/data/raw_text.zip`
|`../../data/raw_text.zip`| `/Users/data/raw_text.zip`
|`../../../data/raw_text.zip`| `/data/raw_text.zip`

## การอ่านเขียนไฟล์ข้อมูล

ไฟล์ถูกจัดเก็บไว้ในฮาร์ดดิสก์ ซึ่งเป็นหน่วยความจำถาวรที่ทำหน้าที่เก็บรักษาข้อมูลไว้อย่างถาวร ฮาร์ดดิสก์แต่ละเครื่องมีขนาดความจุไม่เท่ากัน โดยไฟล์ขนาด 1 MB (1,024,000 ไบต์) สามารถเก็บตัวอักษรได้ประมาณ 500,000 - 1,000,000 ตัว ขึ้นอยู่กับรูปแบบการเข้ารหัสตัวอักษร (encoding) ที่ใช้ เมื่อเราต้องการนำข้อมูลในไฟล์มาประมวลผล จะต้องคัดลอกข้อมูลจากฮาร์ดดิสก์ไปยังแร็ม (RAM) ซึ่งเป็นหน่วยความจำชั่วคราว ข้อมูลในแร็มจะหายไปทันทีเมื่อปิดเครื่อง

การอ่านเขียนไฟล์ข้อมูล (File I/O) เป็นกระบวนการสำคัญในการจัดการข้อมูลในระบบคอมพิวเตอร์ ซึ่งหมายถึงการอ่านไฟล์จากฮาร์ดดิสก์มาลงในแร็ม และการเขียนข้อมูลจากแร็มกลับไปยังฮาร์ดดิสก์ การประมวลผลข้อมูลทำได้บนข้อมูลที่อยู่ในแร็มเท่านั้น เนื่องจากแร็มมีความเร็วสูงกว่าฮาร์ดดิสก์มาก ทำให้การเข้าถึงและประมวลผลข้อมูลทำได้รวดเร็วขึ้น

หากไฟล์มีขนาดใหญ่มาก ๆ เราอาจไม่สามารถโหลดไฟล์ทั้งหมดลงในแร็มได้ในครั้งเดียว เราจึงต้องมีรูปแบบการอ่านไฟล์ที่หลากหลายเพื่อให้เหมาะสมกับขนาดของไฟล์และขนาดของหน่วยความจำที่มีอยู่ เช่น การอ่านไฟล์แบบบรรทัดต่อบรรทัด จะช่วยให้เราสามารถจัดการกับไฟล์ขนาดใหญ่ได้อย่างมีประสิทธิภาพ และลดความเสี่ยงที่จะเกิดข้อผิดพลาดจากการที่หน่วยความจำไม่เพียงพอในการจัดการไฟล์ขนาดใหญ่ ยกตัวอย่างเช่น ในการประมวลผลข้อมูลจากไฟล์ข้อมูลขนาดใหญ่ เช่น ไฟล์ฐานข้อมูลหรือไฟล์ล็อก (log files) เราอาจเลือกใช้วิธีการอ่านไฟล์แบบบรรทัดต่อบรรทัด เพื่อให้สามารถประมวลผลข้อมูลได้ทีละส่วน โดยไม่ต้องโหลดไฟล์ทั้งหมดลงในแร็มพร้อมกัน

### อ่านไฟล์ไล่ทีละบรรทัด
ไพธอนมีคำสั่ง `open()` เป็นฟังก์ชันบิวท์อินเพื่อใช้เปิดไฟล์ คำสั่งนี้ต้องการพาธเป็นพารามิเตอร์เพื่อระบุว่าจะเปิดไฟล์ใด และไฟล์นั้นอยู่ที่ไหน ซึ่งจะใช้พาธเต็มหรือพาธสัมพัทธ์ก็ได้

สมมติว่าเรามีไฟล์ชื่อว่า lydia.txt ซึ่งเป็นข้อมูลเนื้อเพลงที่เราขูดออกมาจากหน้าเว็บ จึงมีความไม่สมบูรณ์อยู่บ้าง
```
ไม่ว่างจริง ๆ
อะหรือว่า

มีคนอื่น
ต่อสายเธอทั้งคืน
ก็เจอแต่ฮืมฝากข้อความ
หาย

ไปเลย
```
เราสามารถใช้คำสั่ง `open` และ method `.readline` เพื่อแสดงผลบรรทัดที่มีข้อความอยู่ดังนี้
```python
song_file = open('lydia.txt')
for line in song_file:
	if line != '\n': # \n เป็นตัวอักขระลงท้ายบรรทัด
		print(line)
song_file.close()
```
ซึ่งจะแสดงผลดังนี้
```
ไม่ว่างจริง ๆ

อะหรือว่า

มีคนอื่น

ต่อสายเธอทั้งคืน

ก็เจอแต่ฮืมฝากข้อความ

หาย

ไปเลย

```
โปรแกรมตัวอย่างข้างบนใช้คำสั่ง `open` ซึ่งรีเทิร์นตัวอ่านไฟล์ จากนั้นเราจะสามารถลูปไปบนแต่ละบรรทัดที่อยู่ในไฟล์ซึ่งโปรแกรมจะมองหาสัญลักษณ์ `\n` (newline) ที่อยู่ในไฟล์เป็นจุดที่แบ่งบรรทัดในข้อความ และรีเทิร์นสตริงนำไปเก็บไว้ในตัวแปรเพื่อไปใช้ในลูปต่อไป  เมื่อเราเปิดไฟล์แล้วควรจะปิดไฟล์ทุกครั้ง เนื่องจากเมื่อเราเปิดไฟล์แล้ว ระบบจัดการไฟล์ของเครื่องคอมพิวเตอร์ของเราอาจจะล็อคไฟล์ๆ นั้นไว้ เพื่อป้องกันไม่ให้โปรแกรมมาเขียนทับในระหว่างที่เราอ่านอยู่ ดังตัวอย่างข้างบน เราปิดไฟล์ด้วย method `.close()`

สตริงที่ได้มาจากการลูปไปบนไฟล์จะลงท้ายด้วย `\n`เสมอเพราะว่าเป็นตัวแบ่งบรรทัด และคำสั่ง `print` จะเติม `\n` เข้าไปให้อีกตัวด้วย เพราะฉะนั้นในตัวอย่างข้างบนเราจะได้บรรทัดว่าง ระหว่างเนื้อร้องแต่ละวรรค (`\n\n` ติดกัน)

ถ้าหากอยากแสดงผลให้สวยงามขึ้น เราต้องใช้คำสั่ง `.strip()` เพื่อเอา `\n` ออกไปจากสตริงก่อนจะเรียก `print`
```python
song_file = open('lydia.txt')
for line in song_file:
	if line != '\n': # \n เป็นตัวอักขระลงท้ายบรรทัด
		print(line.strip())
song_file.close()
```
หรือเราจะลัดโดยการไม่เก็บตัวอ่านไฟล์ไว้ในตัวแปรเลยก็ได้
```python
for line in open('lydia.txt'):
	if line != '\n': # \n เป็นตัวอักขระลงท้ายบรรทัด
		print(line.strip())
```
ซึ่งจะแสดงผลดังนี้
```
ไม่ว่างจริง ๆ
อะหรือว่า
มีคนอื่น
ต่อสายเธอทั้งคืน
ก็เจอแต่ฮืมฝากข้อความ
หาย
ไปเลย
```


### เปิดไฟล์ด้วยคำสั่ง `with` 
วิธีนี้เป็นวิธีที่ปลอดภัยที่สุดในเปิดปิดไฟล์ เพราะเป็นการป้องกันการลืมปิดไฟล์ไปในตัว การใช้ `with` statement เป็นการจำกัดว่าเราจะใช้งานไฟล์นั้นจากจุดใดถึงจุดใด ตัวอย่าง เช่น 
```python
with open('lydia.txt') as songfile:
    for line in songfile:
        if line != '\n': # \n เป็นตัวอักขระลงท้ายบรรทัด
            print(line.strip())
```
สังเกตว่า `with` เป็นคำสงวนในภาษาไพธอน และบังคับให้เราใช้ไฟล์ได้ในเฉพาะ code block ที่อยู่ใต้ `with` เท่านั้นโค้ดที่ตามหลังมาจากนั้นจะไม่สามารถใช้ไฟล์นั้นได้อีกต่อไป เนื่องจาก `with` จะปิดไฟล์ให้โดยอัตโนมัติหลังจากรันโค้ดที่อยู่ใน code block นั้นเสร็จแล้ว หากเราพยายามอ่านจากไฟล์นั้นอีกจะได้ 
`ValueError: I/O operation on closed file.`

การเปิดปิดไฟล์ในวิธีนี้มีข้อดีคือ เราจำกัดตัวเราเองว่าเราสามารถอ่านหรือเปลี่ยนแปลงไฟล์ในช่วงโค้ดที่จำกัดทำให้เราไม่ลืมปิดไฟล์ และทำให้เรารู้ว่าไฟล์ถูกเปลี่ยนแปลงโดยส่วนไหนของโค้ดของเราบ้าง 

### อ่านไฟล์และถ่ายข้อมูลทั้งหมดใส่สตริง: `.read()`
เราสามารถเก็บข้อมูลทั้งหมดในไฟล์ใส่สตริงโดยใช้ method `.read()`
```python
song_lyrics = open('lydia.txt').read()
print(song_lyrics)
```
ผลที่ได้ออกมาคือ
```
ไม่ว่างจริง ๆ
อะหรือว่า

มีคนอื่น
ต่อสายเธอทั้งคืน
ก็เจอแต่ฮืมฝากข้อความ
หาย

ไปเลย

```
คำสั่งนี้ค่อนข้างสะดวกถ้าเราต้องการประมวลผลข้อความทั้งไฟล์ โดยเฉพาะอย่างยิ่งเวลาเราต้องการขูดข้อมูลออกจากไฟล์จำนวนหลายไฟลฺ 
ข้อควรระวังคือ การใช้คำสั่งนี้เป็นการคัดลอกข้อมูลจากไฟล์ซึ่งอยู่ใน harddrive ของเครื่องคอมพิวเตอร์ซึ่งมักจะมีความจุมาก ๆ เช่น 250 gigabyte นำมาใส่หน่วยความจำชั่วคราว (RAM) ซึ่งมักจะมีความจุไม่มาก เช่น 16 gigabyte เพราะฉะนั้นเราใช้คำสั่ง `.read()` เป็นการนำข้อมูลทั้งหมดในไฟล์นั้นมาเก็บใส่ตัวแปรซึ่งเก็บข้อมูลไว้ใน RAM ถ้าไฟล์นั้นมีขนาดใหญ่กว่าหรือเทียบเท่าความจุของ RAM ของคอมพิวเตอร์เรา จะเกิดปัญหาเครื่องคอมพิวเตอร์ค้าง เนื่องจากหน่วยความจำถูกนำไปเก็บข้อมูลจากไฟล์ 

ถ้าหากไฟล์ที่ต้องการประมวลผลมีขนาดใหญ่ และมีหลายบรรทัด แนะนำให้ใช้ `for` ลูปเพื่อค่อยลำเลียงข้อมูลเข้ามาประมวลผลทีละบรรทัด หน่วยความจำ RAM ของเครื่องเก็บข้อมูลไว้แค่ทีละหนึ่งบรรทัดเท่านั้น พอประมวลผลเสร็จหนึ่งบรรทัด พื้นที่หน่วยความจำก็จะถูกแทนที่ด้วยข้อมูลจากบรรทัดถัดไป เช่นนี้ไปเรื่อย ๆ 

### อ่านไฟล์เพียงบางบรรทัด: `.readline()`
บางครั้งเราไม่ต้องการอ่านไฟล์ทั้งไฟล์ ทุกบรรทัด เราสามารถใช้ method `.readline()` ในการดึงข้อมูลออกมาทีละบรรทัด สมมติว่าเราต้องการเขียนโปรแกรมที่ประมวลผลเพียงสามบรรทัดแรกเท่านั้น
```python
with open('lydia.txt') as songfile:
    line1 = songfile.readline()
    line2 = songfile.readline()
print (line1)
print (line2)
```
ผลที่ได้ออกมาคือ
```
ไม่ว่างจริง ๆ

อะหรือว่า

```
ข้อสังเกตคือตัวเปิดไฟล์ (`songfile`) จะเก็บสถานะว่าเราอ่านไฟล์ไปถึงบรรทัดไหนแล้ว เมื่อเราเรียก `.readline` ครั้งต่อมาก็จะอ่านไฟล์ต่อจากการเรียก `.readline` ครั้งที่แล้ว 

เพราะฉะนั้นถ้าเราต้องการอ่านไฟล์แค่บรรทัดสุดท้าย เราต้องไล่อ่านตั้งแต่บรรทัดแรกไปจนถึงบรรทัดสุดท้าย เนื่องจากระบบจัดเก็บไฟล์ของเครื่องคอมพิวเตอร์ไม่ได้รองรับการจากท้ายไฟล์มายังต้นไฟล์ หรือการอ่านจากกลางไฟล์ การอ่านไฟล์ต้องเริ่มต้นจากต้นไฟล์ (ตัวอักษรตัวแรกของไฟล์) เท่านั้น 

### อ่านไฟล์และถ่ายข้อมูลทั้งหมดใส่ลิสต์: `.readlines()`
เราสามารถอ่านไฟล์แล้วเก็บใส่ลิสต์ที่สมาชิกแต่ละตัวเป็นข้อความแต่ละบรรทัดที่อยู่ในไฟล์ คำสั่งนี้เป็นการรวม `.read()` ซึ่งอ่านไฟล์ทั้งไฟล์จะย้ายมาเก็บในตัวแปร และ `.readline()` ซึ่งอ่านไฟล์โดยการแบ่งบรรทัด เพราะฉะนั้นมีข้อควรระวังในการใช้เหมือนการใช้ `.read` ก็คือห้ามเปิดไฟล์ที่มีขนาดใหญ่เกินไป เพราะเครื่องคอมพิวเตอร์อาจจะมีหน่วยความจำไม่พอในการเก็บข้อมูล
```python
lines = open('lydia.txt').readlines()
lines[0] #--> 'ไม่ว่างจริง ๆ\n'
lines[1] #--> 'อะหรือว่า\n'
```
### เขียนสตริงใส่ไฟล์ 
เมื่อเราประมวลผลข้อมูลเสร็จแล้ว เรามักจะต้องบันทึกข้อมูลจากสตริงลงไฟล์ โดยเฉพาะอย่างยิ่งถ้าสตริงเริ่มมีขนาดใหญ่เกินกว่าความจุของ RAM เราต้องทยอยถ่ายข้อมูลใส่ไฟล์ซึ่งอาศัยอยู่ใน hard drive ที่มีความจุมากกว่า RAM มาก ๆ 

วิธีการเขียนสตริงลงไฟล์ ให้เราเปิดไฟล์ขึ้นมาโดยระบุ `mode` เป็น `w` (write) แล้วใช้ method `.write` เช่น
```python
with open('my_fav_song.txt', mode='w') as f:
    f.write('ไม่ว่างจริง ๆ\n')
    f.write('อะหรือว่ามีคนอื่น\n')
```
ข้อควรระวังในการเขียนไฟล์มีดังนี้
1. อย่าลืมตั้ง `mode='w'` เพราะว่าโดย default ไพธอนจะเปิดไฟล์เพื่ออ่านไฟล์เท่านั้น ถ้าไม่ตั้งเป็นโหมดเขียน ไพธอนจะพยายามหาไฟล์นั้นเพื่อเปิดขึ้นมาอ่าน แต่ไฟล์นั้นไม่ได้มีอยู่ก่อนแล้ว เครื่องก็จะโยน `FileNotFoundError` มาให้ ซึ่งทำให้ยิ่งสับสนขึ้นไปอีก
2. เขียนได้เฉพาะสตริงเท่านั้น ถ้าพยายาม `.write` ตัวเลขหรือลิสต์ จะได้ `TypeError`
3. อย่าลืมใส่ `\n'` ถ้าหากต้องการแบ่งข้อความเป็นบรรทัด ไม่ยาวพืดเดียว
 
### เขียนดิกชันนารี หรือลิสต์ใส่ไฟล์โดยใช้ json
ถ้าข้อมูลของเราอยู่ในรูปของดิกชันนารี ลิสต์ ตัวเลข และสตริง เราสามารถจัดเก็บในรูปแบบของ json (อ่านว่า เจซอน หรือ เจสัน) ซึ่งจะแปลงโครงสร้างข้อมูลให้เป็นสตริง เพื่อที่จะนำเขียนลงไฟล์ในรูปแบบที่มนุษย์อ่านได้ 
ไพธอนมีไลบรารี json ที่มีฟังก์ชันที่ช่วยในการอ่านและเขียน json เช่น
```python
import json
lyrics = ['Lydia', 'ไม่ว่างจริง ๆ', 'หรือว่ามีคนอื่น', 'ต่อสายเธอทั้งคืน']
with open('my_fav_song.json', mode='w') as f:
    json.dump(lyrics, f)
```
เรามักจะตั้งสกุลของไฟล์เป็น .json เพื่อทำให้เราและคนอื่น ๆ ทราบว่าจะต้องเปิดไฟล์ด้วยวิธีใด ถ้าหากเราลองเปิดไฟล์โดยใช้ VSCode หรือ Notepad หรือ text editor ตัวอื่น ๆ เราจะเห็นไฟล์ดังนี้
```
["Lydia", "\u0e44\u0e21\u0e48\u0e27\u0e48\u0e32\u0e07\u0e08\u0e23\u0e34\u0e07 \u0e46", "\u0e2b\u0e23\u0e37\u0e2d\u0e27\u0e48\u0e32\u0e21\u0e35\u0e04\u0e19\u0e2d\u0e37\u0e48\u0e19", "\u0e15\u0e48\u0e2d\u0e2a\u0e32\u0e22\u0e40\u0e18\u0e2d\u0e17\u0e31\u0e49\u0e07\u0e04\u0e37\u0e19"]
```
ซึ่งดูแล้วไม่เหมือนกับไฟล์ที่มนุษย์อ่านได้เท่าไร เราจะอ่านออกเฉพาะตัวลาตินของภาษาอังกฤษ ที่จริงตัวหนังสือภาษาไทยถูกจัดเก็บในรูปของรหัส `\uXXXX` ซึ่งเครื่องจะใช้การถอดรหัสแบบ unicode ในการแปลว่า `0e44` คือ `ไ` โดยการเปิดหาในสมุดรหัสทีละตัว ที่เจซอนจัดเก็บข้อมูลแบบนี้โดย default เนื่องจากว่าในสมัยก่อนเครื่องคอมพิวเตอร์บางเครื่องสามารถอ่านหรือแสดงผลได้แค่ตัวอักษรแบบ ascii ซึ่งประกอบไปด้วยอักษรภาษาอังกฤษ ตัวเลข และเครื่องหมายวรรคตอนบางตัวเท่านั้น ไม่สามารถอ่านและแสดงผลตัวอักษรไทย emoji หรือตัวอักษรในระบบการเขียนอื่น ๆ ได้ 

ถ้าหากเราต้องการให้ไฟล์เจซอนสามารถอ่านตัวภาษาไทย หรือตัวอักษรประเภทอื่น ๆ ที่ไม่ใช่ตัวลาตินได้ เราต้องตั้ง `ensure_ascii=False` ซึ่งแปลว่าไม่ต้องจัดเก็บเป็นตัว ascii 
```python
import json
lyrics = ['Lydia', 'ไม่ว่างจริง ๆ', 'หรือว่ามีคนอื่น', 'ต่อสายเธอทั้งคืน']
with open('my_fav_song.json', mode='w') as f:
    json.dump(lyrics, f, ensure_ascii=False)
```
หากต้องการเปิดไฟล์ json ให้ใช้ `json.load`
```python
with open('my_fav_song.json') as f:
    lyrics = json.load(f)
```
วิธีนี้ได้ผลไม่ว่าตอนจัดเก็บเราจะจัดเก็บแบบ `ensure_ascii` ด้วยหรือไม่ เพราะเครื่องคอมพิวเตอร์ในปัจจุบันสามารถประมวลผล unicode ได้เป็นปกติ

## Regular expression

Regular expression (เรียกกันย่อ ๆ ว่า regex อ่านว่า /regeks/ เร็กเก็กส์)  เป็นภาษาในการระบุเขียนจับแพทเทิร์นของตัวอักษรที่เราต้องการตรวจหา เพื่อที่จะได้ดึงหรือแก้ไขข้อมูลที่อยากได้โดยสะดวก ตัวอย่างเช่น 
- ตรวจหาเบอร์โทรศัพท์ซึ่งมีแพทเทิร์นว่า มีตัวเลขทั้งหมด 10 ตัวแต่ตัวแรกต้องเป็น 0 อีก 9 ตัวเป็นอะไรก็ได้ แต่ถ้าตัวเลขมีทั้งหมด 9 ตัว ตัวแรกไม่ต้องเป็น 0 ก็ได้ 
- ตรวจหาอีเมลของพนักงานทุกคนที่มาจากภาครัฐ ซึ่งมีแพทเทิร์นว่า ข้างหน้าเครื่องหมาย @ เป็นตัวภาษาอังกฤษหรือจุดหรือตัวเลขอะไรก็ได้ แต่ข้างหลังเครื่องหมาย @ ต้องเป็นชื่อองค์กรอะไรก็ได้แต่ต้องลงท้ายด้วย .go.th 
- ตรวจหาอักษรย่อขององค์กรที่เป็นภาษาไทย ซึ่งมีแพทเทิร์นว่า ต้องเป็นตัวอักษรไทย 2 - 4 ตัวและลงท้ายด้วย .
แพทเทิร์นเหล่านี้ยากที่จะอธิบายให้เป็นตัวอักษร regular expression เป็นภาษาสื่อกลางที่ช่วยให้เราอธิบายแพทเทิร์นที่เราต้องการให้ได้อย่างชัดเจน

Regex มีความสำคัญมากๆ ในการทำงานเกี่ยวกับการประมวลผลภาษาธรรมชาติ  เพราะทำให้เราสามารถดึงข้อมูลที่มีแพทเทิร์นเด่นชัดในภาษา (เช่น อีเมล์ เบอร์โทรศัพท์ ชื่อ ตัวย่อ) ออกมาจากข้อความที่เราต้องการประมวลผลได้สะดวก ความสำคัญของ regex อีกประการหนึ่งคือ การทำความสะอาดข้อมูล ข้อมูลภาษาที่เราได้รับมามักจะมีข้อความแปลกปลอมหลากหลายประเภทที่จำเป็นต้องกรองออกก่อน ตัวอย่างเช่น ข้อความที่ดาวน์โหลดมาจากทวิตเตอร์อาจจะมีข้อความที่เป็น hashtag หรือ mention ที่เราต้องการกรองออกไป หรือข้อความที่มีลิงก์ที่เราต้องการแปลงเป็นชื่อเว็บไซต์ หรือข้อความที่มีตัวอักษรพิเศษที่เราต้องการลบออกไป เป็นต้น

## สัญลักษณ์ที่ใช้ใน regular expression

Regular expression มีความพิเศษกว่าสตริงปกติ คือตีความหมายสัญลักษณ์พิเศษต่าง ๆ ที่ช่วยระบุแพทเทิร์นที่ซับซ้อนและยืดหยุ่นมาก  เช่น 
- `[a-z.]+@[a-z]+\.com` เป็น regex สำหรับแพทเทิร์นของ email address ที่ลงท้ายด้วย .com
- `\d\d\d-\d\d\d-\d\d\d\d` เป็น regex  สำหรับแพทเทิร์นของหมายถึงเลขโทรศัพท์ เช่น 123-123-1234

สัญลักษณ์ที่ใช้ใน regular expression มีอยู่ 5 ประเภทด้วยกัน คือ

###	ตัวอักษรปกติ (Literal character)
ตัวอักษรปกติคือตัวอักษรที่เราต้องการให้ regex แมทช์กับตัวอักษรนั้น ๆ ตัวอักษรปกติสามารถเป็นตัวอักษรอะไรก็ได้ แต่บางตัวอักษรจะมีความหมายพิเศษใน regular expression ทำให้เราต้องทำการหนี (escape) โดยการเพิ่ม \ เข้าไปข้างหน้า เพื่อบอกว่าเป็นตัวอักษรปกติ ไม่ใช่อักขระพิเศษ ตัวอักษรที่ต้องทำการหนี (escape) ได้แก่ `\` `+` `*` `?` `^` `$` `(` `)` `[` `]` `{` `}` `|` และ `.`

### อักขระพิเศษ (Metacharacter)

อักขระพิเศษเป็นหัวใจสำคัญของการเขียน regex เพื่อระบุแพทเทิร์น เพราะอักขระพิเศษใช้แทนกลุ่มของตัวอักษร อักขระพิเศษมีหลายตัว แต่ในบทนี้เราจะเรียนรู้เพียงอักขระพิเศษที่ใช้บ่อย ๆ ซึ่งเราควรจะจำให้ได้ทั้งหมด ดังนี้

| สัญลักษณ์ | แทนตัวอะไรบ้าง                        |
|--------|-------------------------------------|
| ^      | หน้าสุดของ string                     |
| $      | ท้ายสุดของ string                     |
| .      | ตัวอะไรก็ได้                           |
| \w     | (**w**ord) a-z A-Z 0-9 และ _  |
| \W     | อะไรก็ได้ที่ไม่ใช่ \w                     |
| \d     | (**d**igit) ตัวเลข 0-9              |
| \D     | อะไรก็ได้ที่ไม่ใช่ \d                     |
| \s     | (**s**pace) ช่องว่างรวมถึง \t (แท็บให้ขึ้นย่อหน้าใหม่) \n (new line บ่งบอกการขึ้นบรรทัดใหม่) และ \r (new line แบบของ Windows)   |
| \S     | อะไรก็ได้ที่ไม่ใช่ \s                     |
| \b     | ตัวแบ่งคำ (แบบภาษาอังกฤษ)              |

ข้อสังเกตอย่างหนึ่งเพื่อให้ช่วยจำได้ง่ายขึ้น คือ \w \d และ \s จะจับคู่กับเวอร์ชั่นที่เป็นตัวพิมพ์ใหญ่ซึ่งเป็นเวอร์ชั่นที่เป็นนิเสธของ \w \d และ \s ตามลำดับ เช่น \w หมายถึง a-z A-Z 0-9 และ _ แต่ \W เป็นนิเสธของ \w จึงแมทช์กับอะไรก็ได้ที่ไม่ใช่ a-z A-Z 0-9 และ _ ดังนั้น \W จะจับคู่กับตัวอักษรพิเศษ และช่องว่าง แต่ไม่จับคู่กับตัวอักษรทั่วไป เป็นต้น

#### ตัวอย่าง regex ที่ใช้อักขระพิเศษ 1
`\d\d\d-\d\d\d-\d\d\d\d` เป็น regex  สำหรับแพทเทิร์นของหมายเลขโทรศัพท์ เริ่มต้นด้วยตัวเลข (\d) 3 ตัว ตามด้วยเครื่องหมายขีดกลาง แล้วตามด้วยตัวเลข (\d) 3 ตัว ตามด้วยเครื่องหมายขีดกลาง แล้วตามด้วยตัวเลข (\d) 4 ตัว 

| สตริง | แมทช์กับ regex | คำอธิบาย |
|------|--------------|----------|
| 123-123-1234 |  ✔️ |             |
| 123-123-12345 | ❌ |  เพราะว่ามีตัวเลข 5 ตัว หลังขีดสุดท้าย |
| a23-123-1234 | ❌ |  เพราะว่า \d ตัวแรกไม่แมทช์กับ a |
| ๑๒๓-๑๒๓-๑๒๓๔ | ❌ |  เพราะว่า \d แมทช์กับเลขอารบิกเท่านั้น |

#### ตัวอย่าง regex ที่ใช้อักขระพิเศษ 2
`\w\.\w\.\w\.` เป็น regex สำหรับแพทเทิร์นของตัวย่อที่มีสามตัวอักษร แต่แต่ละตัวอักษรคั่นด้วยจุด เช่น `a.b.c.` `a.b.c.` `a.b.c.` เป็นต้น อย่าลืมว่าเราต้องทำการหนี `.` โดยการใช้ `\.` เพราะ `.` เป็นอักขระพิเศษ

| สตริง | แมทช์กับ regex | คำอธิบาย |
|------|--------------|----------|
| U.S.A. |  ✔️ |             |
| ABC | ❌ |  เพราะว่าไม่มีจุดคั่นตามที่ระบุในแพทเทิร์น |
| พ.ร.บ. | ❌ |  เพราะว่า \w ไม่แมทช์กับตัวอักษรไทย |

อักขระพิเศษถูกออกแบบมาตอนที่ชุดอักขระมีเพียงแค่ตัวลาตินและเครื่องวรรคตอนเท่านั้น เพราะฉะนั้นถึงแม้ว่า \w ถูกออกแบบมาเพื่อจับคู่กับตัวอักษรที่ประกอบขึ้นมาเป็นคำ แต่ว่าไม่ได้ครอบคลุมถึงสตริงไม่ได้ใช้ได้ตัวลาติน เช่น ภาษาไทย ภาษาจีน ภาษาเกาหลี ภาษาญี่ปุ่น  ซึ่งเราจะเรียนรู้วิธีการจับคู่กับสตริงที่ไม่ใช่ตัวลาตินในตัวอย่างต่อไป

### การจัดเซ็ตของตัวอักษร
อักขระพิเศษมีข้อจำกัด เพราะมีการจัดกลุ่มมาแน่นอนอยู่แล้ว เช่น ตัวเลข ตัวอักษรลาติน ช่องว่าง แต่ถ้าหากเราต้องการจัดกลุ่มตัวอักษรตามที่เราต้องการเอง เราสามารถทำได้โดยการใช้เครื่องหมายวงเล็บเหลี่ยม `[]` เพื่อจับกลุ่มตัวอักษร และ `|` เพื่อจัดกลุ่มแพทเทิร์น 

เครื่องหมาย `[]` ใช้ในการระบุว่าตัวอักษรใดบ้างที่จะแมทช์กับแพทเทิร์น เช่น `[abc]` แปลว่าตัวอักษร a หรือ b หรือ c แต่ถ้าหากเราต้องการให้แมทช์กับตัวอักษรที่ไม่ใช่ a หรือ b หรือ c เราสามารถใช้เครื่องหมาย `^` นำหน้าได้ เช่น `[^abc]` แปลว่าตัวอักษรอะไรก็ได้ที่ไม่ใช่ a หรือ b หรือ c สรุปได้ดังนี้

| สัญลักษณ์     | แทนตัวอะไรบ้าง       | ตัวอย่าง                         |
|------------|--------------------|--------------------------------|
| `[abc]`      | ตัวอักษรตัวหนึ่งใน set  | `b[aei]d` match bad bed bid     |
| `[^abc]`     | อะไรก็ได้ที่ไม่อยู่ใน set | `b[^aei]d` match bbd bcd bdd  |
| `aaa\|bb\|c` | aaa หรือ bb หรือ c   | `bea\|ook` match bea ook         |

เครื่องหมาย `-` ที่อยู่ใน `[]` ใช้สำหรับการไล่ตัวอักษร เช่น 
- `[a-z]` แปลว่าตัวอักษรที่อยู่ใน a ถึง z  
- `[0-9]` แปลว่าตัวอักษรที่อยู่ใน 0 ถึง 9 ซึ่งความหมายเหมือนกับ \d


| สัญลักษณ์     | แทนตัวอะไรบ้าง       | ตัวอย่าง                         |
|------------|--------------------|--------------------------------|
| `[a-z]`      | ไล่ตัวอักษรทำเป็น set  | `[b-d]ad` match bad cad dad      |
| `[^abc]`     | อะไรก็ได้ที่ไม่อยู่ใน set | `b[^aei]d` match bbd bcd bdd  |
| `aaa\|bb\|c` | aaa หรือ bb หรือ c   | `bea\|ook` match bea ook         |

### ตัวบอกปริมาณ (Quantifier)

เราสามารถระบุปริมาณของตัวอักษรหรือกลุ่มของตัวอักษรโดยการใช้ตัวอักษรร่วมกับ quantifier

| quantifier | แปลว่า                            |
|------------|----------------------------------|
| +          | อย่างน้อยหนึ่งตัว (1 or more)         |
| *          | กี่ตัวก็ได้ หรือไม่มีสักตัวก็ได้ (0 or more) |
| ?          | 1 ตัว หรือไม่มีก็ได้ (0 or 1)          |
| {n}        | n ตัวเป๊ะๆ                         |
| {m,n}      | m - n ตัว                         |
| {n,}       | อย่างน้อย n ตัว                     |
| {,n}       | อย่างมาก n ตัว                     |

ตัวอย่าง

| regex | แปลว่า | ตัวอย่างที่แมทช์ |  
| ----- | ------ | --- | 
| \d+   | ตัวเลขอย่างน้อยหนึ่งตัว | 1113333 
| [ก-ฮ]{2} \d{4} | ตัวอักษรไทย 2 ตัว ตามด้วยตัวเลข 4 ตัว (เลขทะเบียนรถ) |  ตอ 6465 |

#### ตัวอย่าง regex ที่ใช้ตัวบอกปริมาณ 1
`\w+\.\w@chula\.ac\.th` เป็น regex สำหรับแพทเทิร์นของ email address ที่โดเมนคือ chula.ac.th 
- เริ่มต้นด้วยตัวอักษร (\w) หนึ่งตัวขึ้นไป
- ตามด้วยเครื่องหมายจุด ซึ่งเครื่องหมายจุดต้องมีการหนีโดยการใช้ backslash `\.` เพราะ `.` เป็นอักขระพิเศษ
- ตามด้วยตัวอักษร (\w) หนึ่งตัว
- ตามด้วยเครื่องหมาย @
- ตามด้วยคำว่า chula.ac.th ซึ่งเครื่องหมายจุดทั้งสองตัวต้องมีการหนีโดยการใช้ backslash `\.` เพราะ `.` เป็นอักขระพิเศษ 


| สตริง | แมทช์กับ regex | คำอธิบาย |
|------|--------------|----------|
| attapol.t@chula.ac.th |  ✔️ |             |
| 123-123-12345 | ❌ |  เพราะว่ามีตัวเลข 5 ตัว หลังขีดสุดท้าย |
| a23-123-1234 | ❌ |  เพราะว่า \d ตัวแรกไม่แมทช์กับ a |


### การอ้างอิงกลับ (Backreference)
การอ้างอิงกลับ คือการส่วนที่แมทช์ใน regex มาอ้างถึงอีกครั้ง เหมือนกับการระบุว่าแมทช์แพทเทิร์นเดียวกับที่แมทช์ไปแล้ว ซึ่งก่อนที่จะให้ regex อ้างถึงแพทเทิร์นก่อนหน้านี้ จะต้องมีการจับกลุ่มโดยการใช้วงเล็บ `()`  ในการจัดกลุ่มเพื่อที่จะอ้างถึงได้ในภายหลัง จากนั้นจึงมีการอ้างอิงกลับด้วยหมายเลขกลุ่ม `\1` เพื่ออ้างอิงกลับถึงจับกลุ่มด้วย `()` คู่แรก `\2`เพื่ออ้างอิงกลับถึงจับกลุ่มด้วย `()` คู่ที่สอง เช่น 
```
(\w+) \1 
```
แปลว่าแพทเทิร์นที่ขึ้นตัวด้วยตัวอักษรอย่างน้อยหนึ่งตัว ซึ่งให้เรียกว่ากลุ่มที่ 1 เนื่องจากเราใส่ไว้ในวงเล็บมน จากนั้นตามด้วยช่องว่างหนึ่งช่อง และตามด้วยแพทเทิร์นที่เราแมทช์ไปแล้วในกลุ่มที่หนึ่ง ซึ่งเราใช้ `\1` ในการอ้างถึงกลับไปยังกลุ่มที่หนึ่ง  ดังนั้น regex นี้จะแมทช์กับสตริงที่มีคำที่ซ้ำกันอยู่ติดกัน เช่น
`hello hello` หรือ `bye bye` หรือ `hi hi` แต่ว่า `hello hi` ไม่แมทช์เพราะว่า `\1` จะต้องแมทช์กับสตริงที่แมทช์กับ regex ใน `()` แรก 

สมมติว่าเราต้องการแมทช์ข้อความที่มีแพทเทิร์น เช่น `มอร์นิ่งค่่ะ มอร์นิ่ง` `ดีค่่ะ ดี` `จบค่่ะ จบ` `แยกย้ายค่่ะ แยกย้าย` แต่ไม่แมทช์กับ `มอร์นิ่งค่่ะ ดี` `ดีค่่ะ จบ` `จบค่่ะ แยกย้าย` เราสามารถใช้ backreference ในการแก้ปัญหานี้ได้ดังนี้
```
^(\w+)ค่ะ \1$
```
คำอธิบาย
- `^` แปลว่าต้องขึ้นต้นด้วย
- `(\w+)` แปลว่าตัวอักษรอย่างน้อยหนึ่งตัว ซึ่งเราใส่ไว้ในวงเล็บเพื่อบ่งบอกว่าการจับกลุ่ม ทำให้สามารถ backreference กลับได้
- `ค่ะ ` เป็นสตริงปกติ
- `\1` แปลว่าอ้างถึงกลุ่มที่หนึ่ง ซึ่งกลุ่มก็คือสตริงที่ถูกแมทช์ด้วย `(\w+)` 

## Regular expression ในภาษาไพธอน
คำสั่งที่เกี่ยวกับ regular expression อยู่ในโมดูล `re` ของไพธอน คำสั่งที่จำเป็นต้องทราบสำหรับการใช้ regular expression มีอยู่ 5 คำสั่ง

| ฟังก์ชัน  | จุดประสงค์การใช้ | 
|--------|--------------|
| `re.match` | ตรวจสอบว่า regex match กับต้นสตริงหรือไม่ | 
| `re.search` | ตรวจสอบว่า regex match กับส่วนใดส่วนหนึ่งของสตริงหรือไม่ | 
| `re.findall` | หาส่วนที่ regex match ทั้งหมด
| `re.sub` | แทนที่ส่วนที่ regex match ด้วยสตริงอีกสตริงหนึ่ง 
| `re.split` | หั่นสตริงออกเป็นลิสต์ โดยใช้ regex เป็นตัวบ่งบอกส่วนที่ใช้หั่นสตริง 

ทั้ง 5 คำสั่งเป็นคำสั่งที่ต้องเราเขียน regex เพื่อระบุแพทเทิร์นที่เราต้องการหา ในภาษาไพธอนเรามักจะระบุ regex โดยการใช้สตริงดิบ หรืออาร์สตริง (raw string หรือ r string) อาร์สตริงมีวิธีการสร้างเหมือนกับสตริงทั่วไปเพียงแต่ว่าเราจะมีตัวอักษร `r` ก่อนเครื่องหมาย `'` หรือ `""` ที่เราใช้นำหน้าสตริงทั่วไป เช่น regex สำหรับหาหมายเลขโทรศัพท์ประเทศไทย 10 หลัก จะเขียนได้เป็น
```python
phone_regex = r'\d\d\d-\d\d\d-\d\d\d\d'
```
จริง ๆ แล้วเราจะใช้สตริงธรรมดาแทนก็ได้ แต่ว่ามีอักขระพิเศษบางสัญลักษณ์ที่สตริงธรรมดา และอาร์สตริงมีความหมายต่างกัน เช่น '\b' ในสตริงธรรมดาหมายถึง backspace แต่ในอาร์สตริงหมายถึงตัวแบ่งคำ ดังนั้นเราจึงควรใช้อาร์สตริงในการเขียน regex แทน

### `re.match` 
คำสั่งนี้ต้องการ regular expression ที่บ่งบอกแพทเทิร์น และสตริงที่ต้องการจะตรวจสอบ 
```python
import re
match = re.match(r'นาย([ก-์]+)พล ([ก-์]+)', 'นายณัฐพล โคกสูงเนิน')
if not match:
    print ('ชื่อไม่แมทช์กับแพทเทิร์นนี้')
```
คำสั่ง `re.match` จะรีเทิร์น match object กลับมาให้ถ้าหากแพทเทิร์นแมทช์กับสตริงที่ระบุไว้ ถ้าหากไม่เราจะได้ `None` คืนกลับมาแทน 

ถ้าหากเราต้องการทราบด้วยว่าแพทเทิร์นไป match ส่วนใดของสตริงบ้าง เราต้องใช้ match object ที่รีเทิร์นมา และใช้ method ที่ชื่อว่า `.group` ซึ่งจะรีเทิร์นสตริงที่แมทช์กับกลุ่มแพทเทิร์นที่ระบุไว้กลับมาให้ 
```python
import re
match = re.match(r'นาย([ก-์]+)พล ([ก-์]+)', 'นายณัฐพล โคกสูงเนิน')
if not match:
    print ('ชื่อไม่แมทช์กับแพทเทิร์นนี้')
else:
    print (match.group(0)) # นายณัฐพล โคกสูงเนิน
    print (match.group(1)) # ณัฐ
    print (match.group(2)) # โคกสูงเนิน
```
ข้อสังเกตแรกคือเราใช้ `()` ใน regex ข้างต้นเพื่อเป็นการจัดกลุ่มที่เราสามารถอ้างถึงได้ภายหลังด้วยคำสั่ง `.group` โดย group ที่ 0 จะอ้างถึงทั้งแพทเทิร์น ส่วน group ต่อ ๆ มาจะเรียงจากซ้ายไปขวา 

### `re.search`
คำสั่งคล้ายกับ `re.match` เกือบทุกประการ เพียงแต่ว่าจะคำสั่งนี้จะสแกนหาทั้งสตริง เพื่อหาว่าแพทเทิร์นไปแมทช์กับส่วนใดส่วนหนึ่งของสตริงหรือไม่ ไม่ได้จำกัดแค่ตัวอักษรแรกของสตริงเหมือนกับ `.match` 

```python
import re
match = re.match(r'นาย([ก-์]+)พล ([ก-์]+)', 'ได้เข้าพบนายณัฐพล โคกสูงเนิน') # None เพราะไม่มีแมทช์ตั้งแต่ต้นสตริง
match = re.search(r'นาย([ก-์]+)พล ([ก-์]+)', 'ได้เข้าพบนายณัฐพล โคกสูงเนิน') # match 
print (match.group(0)) # นายณัฐพล โคกสูงเนิน
print (match.group(1)) # ณัฐ
print (match.group(2)) # โคกสูงเนิน
```
match object ที่รีเทิร์นกลับมามีวิธีการใช้เช่นเดิม

### `re.findall`
คำสั่งนี้ใช้ในสถานการณ์ที่เราทราบว่าแพทเทิร์นที่เราระบุใน regex นั่นเกิดขึ้นซ้ำกันหลาย ๆ ครั้ง และเราต้องการดึงข้อความที่แมทช์กับ regex ทั้งหมดมาเก็บไว้ในลิสต์ ซึ่งต่างจาก `re.search` และ `re.match` ซึ่งจะให้ส่วนของสตริงที่แมทช์มาแค่ส่วนเดียวเท่านั้น

สมมติว่าเราต้องการหาคำที่ลงท้ายด้วย -s ทั้งหมด
```python
import re
pattern = r'\w+s'
sentence = 'James misses the stitches that Carlos fixes'
s_words = re.findall(pattern, sentence)
s_words # --> ['James', 'misses', 'stitches', 'Carlos', 'fixes']
```

สมมติว่าเราต้องการหาคำที่ลงที่เราเติม -es ต่อท้ายเพื่อเปลี่ยนคำนามภาษาอังกฤษให้เป็นพหูพจน์ หรือเปลี่ยนคำกริยาภาษาอังกฤษให้เป็นรูป present tense สำหรับประธานที่เป็นบุรุษที่สามเอกพจน์ กล่าวคือเราต้องการหาคำที่ลงท้ายด้วย -xes -ches -shes -zes -ses ในประโยค
` เท่านั้น เช่น
```python
import re
pattern = r'\w+(x|tch|sh|z|s)es'
sentence = 'James misses the stitches that Carlos fixes'
es_words = re.findall(pattern, sentence)
es_words # --> ['s', 'tch', 'x']
```
ถ้าหาก regex มีการใช้ `()` หนึ่งครั้ง เรารีเทิร์นมาเฉพาะส่วนที่อยู่ใน `() เท่านั้นซึ่งต่างจากตอนที่เราใช้ regex แบบไม่มี `()` ซึ่งจะสตริงที่แมทช์แบบเต็ม ๆ กลับมาให้

แต่ถ้าหาก regex มีการใช้ `()` มากกว่าหนึ่งครั้ง เรารีเทิร์นมาทุกกลุ่ม กลายเป็นลิสต์ขของทูเปิล เช่น
```python
import re
pattern = r'(\w+(x|tch|sh|z|s)es)'
sentence = 'James misses the stitches that Carlos fixes'
es_words = re.findall(pattern, sentence)
es_words # --> [('misses', 's'), ('stitches', 'tch'), ('fixes', 'x')]
```
ในทั้งสองตัวอย่างให้สังเกตว่าคำสั่งนี้จะคืนค่ามาเป็นลิสต์ของสตริง หรือลิสต์ของทูเปิล ไม่ได้คืนค่ามาเป็น match object เหมือนคำสั่ง `re.match` และ `re.search` 

### `re.sub`
คำสั่งนี้ย่อมาจากภาษาอังกฤษ **sub**stitute แปลว่าการแทนค่า คำสั่งนี้ไว้สำหรับการแทนที่ส่วนของสตริงที่แมทช์กับ regex ด้วยสตริงอื่น ๆ หรือสตริงว่างก็ได้ ซึ่งเป็นคำสั่งที่ใช้บ่อยในการประมวลผลข้อความ 
```
re.sub(regex ที่ต้องการแทนค่า (สตริง), สิ่งที่จะมาแทน (สตริง), สตริงที่ต้องทำการแมทช์และแทนค่า)
```

### ตัวอย่างการใช้งานเบื้องต้น
สมมติว่าเราต้องการแทนที่คำว่า "สวัสดี" ด้วยคำว่า "สวัสดีครับ" ในประโยค ในกรณีนี้เราไม่จำเป็นต้องใช้อักขระพิเศษของ regex เลย สามารถใช้สตริงเป็นแพทเทิร์นได้เลย 

```python
import re
text = 'สวัสดีทุกท่านที่มาร่วมงานในวันนี้'
text = re.sub(r'สวัสดี', 'สวัสดีครับ', text)
text # --> 'สวัสดีครับทุกท่านที่มาร่วมงานในวันนี้'
```

สมมติว่าเราต้องการแทนที่คำว่า "คะ" และ "ค่ะ" ด้วยคำว่า "ครับ" ในกรณีนี้เราจะใช้สัญลักษณ์ `|` ใน regex เพื่อบอกว่าเราต้องการแทนที่คำว่า "คะ" หรือ "ค่ะ" ด้วยคำว่า "ครับ"

```python
import re
text = 'สวัสดีค่ะ ชื่อนัทนะคะ ยินดีรับใช้ค่ะ'
text = re.sub(r'คะ|ค่ะ', 'ครับ', text)
text # --> 'สวัสดีครับ ชื่อนัทนะครับ ยินดีรับใช้ครับ'
```
### ตัวอย่างการใช้งานแบบมีการอ้างอิงกลับ

สมมติว่าเราต้องการเปลี่ยนคำนามที่เป็นรูปพหูพจน์ทีเกิดจากการเติม -es ต่อท้ายคำ ให้กลายเป็นคำนามที่เป็นรูปเอกพจน์ ในกรณีนี้เราจะใช้สัญลักษณ์ `()` ใน regex เพื่อบอกว่าเราต้องการแทนที่ส่วนที่แมทช์กับ regex ด้วยสตริงอื่น ๆ ซึ่งสตริงนั้นจะเป็นส่วนที่อยู่ใน `()` ซึ่งเราสามารถอ้างถึงได้ด้วย `.group` ของ match object ที่รีเทิร์นกลับมาจาก `re.sub` ได้

```python
import re
text = 'James misses the stitches that Carlos fixes'
text = re.sub(r'(\w+)(x|tch|sh|z|s)es', r'\1\2', text)
text # --> 'James miss the stitch that Carlos fix'
```

## re.split
คำสั่งนี้ใช้ในการหั่นสตริงออกเป็นลิสต์ โดยใช้ regex เป็นตัวบ่งบอกส่วนที่ใช้หั่นสตริง คำสั่งนี้คล้ายคลึงกับสตริง method ที่ชื่อว่า `.split` แต่ว่า `re.split` มีความยืดหยุ่นกว่า เพราะว่า `str.split` ต้องระบุตัวแบ่ง (delimiter) เป็นสตริงไม่สามารถระบุเป็นแพทเทิร์นที่ซับซ้อนได้ `re.split` ใช้ regex ในการกำหนดตัวแบ่ง 

สมมติว่าเราต้องการหั่นสตริงด้านล่างออกเป็นลิสต์ โดยใช้เครื่องหมาย `,` หรือ `;` หรือช่องว่างเป็นตัวบ่งบอกส่วนที่ใช้หั่นสตริง ในกรณีนี้เราจะใช้ regex `[,;\s]+` ซึ่งหมายถึงเครื่องหมาย `,` หรือ `;` หรือช่องว่างหนึ่งช่องหรือมากกว่า ในการหั่นสตริงออกเป็นลิสต์ดังนี้
```python
import re
data = "Apples; Oranges, Bananas ;Grapes,Watermelons;Pineapples"
items = re.split(r'[,;\s]+', data)
items # --> ['Apples', 'Oranges', 'Bananas', 'Grapes', 'Watermelons', 'Pineapples']
```

## สรุป
ในบทนี้เราได้เรียนรู้เกี่ยวกับ regular expression ซึ่งเป็นเครื่องมือที่ใช้ในการกำหนดแพทเทิร์นในสตริง โดยใช้อักขระพิเศษต่าง ๆ เช่น  `^ $ . + * ? [ ] { } | ( ) \w \W \d \D \s \S \b` และได้เรียนรู้วิธีการใช้งาน quantifier ใน regular expression ซึ่งประกอบด้วยสัญลักษณ์ `+ * ? {n} {m,n} {n,} {,n}` และได้เรียนรู้วิธีการใช้งานการอ้างอิงกลับ (backreference) 

ภาษาไพธอนมีโมดูลในการทำงานกับ regular expression คำสั่งที่ใช้บ่อย ๆ ในการประมวลข้อมูล ได้แก่ `re.match` `re.search` `re.findall` `re.sub` `re.split` ซึ่งใช้ในการตรวจหาแพทเทิร์นตามที่กำหนดด้วย regular expression ในสถานการณ์ต่าง ๆ 