# บทที่ 3 </br> โครงสร้างข้อมูล (Data Structure) I

โครงสร้างข้อมูล (Data Structure) เป็นสิ่งที่ใช้เก็บข้อมูล เพื่อให้เราสามารถจัดเก็บ ค้นหา และจัดการนำมาใช้ได้อย่างดี และเป็นสิ่งที่สำคัญมากที่นักเขียนโปรแกรมทุกคนควรเข้าใจเป็นอย่างดี โดยเฉพาะอย่างยิ่งผู้ที่สนใจทางด้านวิทยาการข้อมูล (data science) เพราะต้องทำการจัดเก็บ เคลื่อนย้าย และนำข้อมูลไปคำนวณค่าต่าง ๆ เป็นประจำ


```{admonition} จุดมุ่งหมายของบทนี้
- เลือกใช้โครงสร้างข้อมูลประเภทสต์ (list) ดิกชันนารี (dictionary) ทูเปิล (tuple) เคาวน์เตอร์ (counter) และเซ็ต (set) ให้เข้ากับโจทย์ได้อย่างถูกต้อง
- การใช้ `for` `while` ร่วมกับโครงสร้างข้อมูลที่ซับซ้อนขึ้น
- ใช้เมท็อดของโครงสร้างข้อมูลเพื่อแก้โจทย์ได้อย่างมีประสิทธิภาพ
```

 โครงสร้างข้อมูลมีอยู่หลากหลายแบบซึ่งในบทนี้เราจะเรียนรู้วิธีการใช้ลิสต์ (list) ดิกชันนารี (dictionary) ทูเปิล (tuple) เคาวน์เตอร์ (counter) และเซ็ต (set) ในการเก็บข้อมูล เวลาเลือกใช้โครงสร้างข้อมูล เราต้องคำนึงถึง 3 อย่าง

1. ความถูกต้อง กล่าวคือข้อมูลจะต้องไม่สูญหายหรือผิดเพี้ยนไปจากความตั้งใจของเรา เช่น โครงสร้างข้อมูลบางอย่างไม่เก็บข้อมูลที่ซ้ำไว้ หรือโครงสร้างข้อมูลบางอย่างไม่สนใจลำดับในการจัดเก็บข้อมูล
2. ความรวดเร็ว เนื่องจากโครงสร้างข้อมูลแต่ละอย่างมีวิธีการเก็บข้อมูลที่ต่างกัน ทำให้เวลาที่ใช้ในการค้นหาข้อมูลเพื่อดึงเอามาใช้นั้นต่างกันไปด้วย
3. ความสะดวก โครงสร้างข้อมูลมีเมท็อดที่ต่างกัน ทำให้งานบางอย่างทำได้สะดวกมากน้อยต่างกัน เช่น ลิสต์เท่านั้นที่รองรับการดึงข้อมูลออกมาตามลำดับตัวอักษรอย่างสะดวก ๆ ขั้นตอนน้อย หากเราจำเป็นต้องดึงข้อมูลในลักษณะนี้เราต้องเลือกใช้ลิสต์ในการเก็บข้อมูล

ในบทนี้และบทที่ 5 เราจะศึกษาวิธีการใช้โครงสร้างข้อมูลหลากหลายแบบ ซึ่งเราจำเป็นต้องทราบ
1. วิธีการสร้างโครงสร้างข้อมูล
2. วิธีการเพิ่มข้อมูลเข้าไปในโครงสร้าง
3. วิธีการแก้ไขข้อมูลที่อยู่ในโครงสร้าง
4. วิธีการดึงข้อมูลออกมาโดยการใช้ลูป
5. วิธีการดึงข้อมูลออกมาโดยการใช้ method ต่าง ๆ 
6. ข้อดี ข้อเสียของโครงสร้างข้อมูล

```{margin} คำศัพท์
โครงสร้างข้อมูล คือ วิธีการจัดเก็บข้อมูลในคอมพิวเตอร์ เพื่อให้ค้นหา และประมวลผลข้อมูลได้อย่างมีประสิทธิภาพ
```


## ลิสต์ (List)

ลิสต์ เป็น โครงสร้างข้อมูลที่เก็บข้อมูลแบบเป็นลำดับ คล้ายกับการนำข้อมูลมาเรียงแถวกัน 

ข้อสังเกตที่สำคัญของลิสต์คือ มีความคล้ายคลึงกับสตริงมาก สตริงที่จริงแล้วก็คือลิสต์ที่เก็บตัวอักขระเท่านั้น  เพียงแต่ว่ามี method บางอย่างที่ต่างกัน จากบทนี้เราควรใช้ความรู้ความเข้าใจเรื่องสตริงมาประกอบกับการทำความเข้าใจการใช้ลิสต์จะทำให้เข้าใจได้เร็วขึ้น

### สร้างลิสต์ด้วย `[]`
ลิสต์ถูกสร้างได้ด้วยการใช้ `[]` ซึ่งห้ามใช้ `()` หรือ `{}` แทน
```python
my_first_list = []
```
ตัวแปร `my_first_list` เป็นลิสต์เปล่าที่ไม่มีข้อมูลหรือสมาชิกเก็บอยู่เลย

หากต้องการสร้างลิสต์ที่เป็นค่าคงที่ (literal) กล่าวคือสมาชิกของลิสต์ถูกระบุเอาไว้โดยตรงในโค้ด เราสามารถใช้ `[]` คร่อมข้อมูลที่ต้องการเก็บ (เรียกว่า สมาชิกของลิสต์) โดยที่ข้อมูลแต่ละตัวจะเป็น `int float` หรือสตริงก็ได้คั่นด้วยเครื่องหมาย `,` 

สมมติว่าเราต้องการสร้างลิสต์ที่เก็บยอดขายหกเดือนแรก และสร้างอีกลิสต์เพื่อเก็บชื่อเดือน
```python
sales_list = [12, 10, 5, 2, 5 10]
months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June']
```
ตัวแปร `sales_list` และ `months` เป็นลิสต์เก็บ `int` และสตริงตามลำดับ ซึ่งทั้งสองลิสต์มีสมาชิกทั้งหมด 6 ตัวเท่ากัน

ลิสต์สามารถเก็บข้อมูลต่างประเภทได้ด้วย เช่น
```python
sales_list = ['Jan', 12, 'Feb', 10]
```
นักเขียนโปรแกรมมักจะไม่แนะนำให้สร้างลิสต์ในลักษณะนี้ เพราะว่ามักจะทำให้สับสนว่าลิสต์เก็บอะไรไว้อยู่บ้าง ทางที่ดีคือสมาชิกในลิสต์ทุกตัวควรจะเป็นประเภทเดียวกัน และสื่อความหมายเดียวกัน 

### ชื่อตัวแปรที่เก็บลิสต์
ชื่อตัวแปรที่ใช้ในการเก็บลิสต์โดยกฏแล้วจะเป็นอะไรก็ได้ แต่เพื่อทำให้โค้ดเข้าใจได้ง่ายขึ้น นักเขียนโปรแกรมมักตั้งชื่อลิสต์ตามสิ่งที่เก็บอยู่ตามด้วย `_list` หรือเปลี่ยนให้เป็นพหูพจน์แทน เช่น ถ้าสร้างลิสต์ขึ้นมาเพื่อเก็บนามสกุลก็ควรจะตั้งชื่อตัวแปรว่า `last_name_list` หรือ `last_names` หรือ ถ้าสร้างลิสต์ขึ้นมาเพื่อเก็บจำนวนคำที่อยู่ในแต่ละประโยค ควรจะตั้งชื่อตัวแปรว่า `num_words_list` แต่ว่าชื่อ `num_words` อาจจะกำกวมว่าเก็บไว้เป็น `int` หรือไม่ เพราะว่าสิ่งที่เก็บเป็นคำพหูพจน์อยู่แล้ว 

### สร้างลิสต์จากสตริง
````{sidebar} ตัวอย่าง
```python
sentence = "Let's go crazy crazy crazy 'til we see the sun"
word_list = sentence.split(' ')
```
````
สตริง method `.split` ใช้เวลาเราต้องการเปลี่ยนสตริงให้เป็นลิสต์ โดยที่ต้องกำหนดว่าจะใช้สตริงอะไรแบ่งสมาชิกแต่ละตัว ในตัวอย่างนี้เราใช้ `' '` ช่องว่างในการแบ่ง ในการทำ Natural Language Processing เราใช้คำสั่งนี้บ่อยมากในการตัดคำ ซึ่งก็คือการเปลี่ยนสตริงยาว ๆ ให้เป็นลิสต์ของคำ

### หาความยาวของลิสต์ (จำนวนสมาชิก): len(list)
````{sidebar} ตัวอย่าง
```python
sentence = "Let's go crazy crazy crazy 'til we see the sun"
word_list = sentence.split(' ')
len(word_list) #---> 10
```
````
ไพธอนมีฟังก์ชันบิวท์อิน `len` ที่ใช้หาจำนวนสมาชิกของลิสต์ และโครงสร้างข้อมูลอื่น ๆ ของไพธอนทั้งหมด ฟังก์ชันนี้จะรีเทิร์น `int` เสมอ ตัวอย่างที่ใช้บ่อย ๆ คือใช้ต่อการสร้างลิสต์จากสตริงเพื่อนับจำนวนคำที่อยู่ในประโยคหรือข้อความ เนื่องจากภาษาที่ใช้ตัวเขียนเป็นตัวลาตินสามารถตัดคำโดยใช้คำสั่ง `split` ได้ง่าย ๆ ถึงแม้ว่าจะไม่ได้แม่นยำเสมอไป


### เข้าถึงสมาชิกในลิสต์โดยใช้ index
การเข้าถึงสมาชิกแต่ละตัว เราจะใช้ operator `[]` และกฏการใช้ index ที่เหมือนกับสตริงทุกประการ สมาชิกตัวแรกอยู่ที่ index 0 และสามารถใช้ negative indexing ในการนับ index ถอยหลังจากท้ายลิสต์ได้ ตัวอย่างเช่น 

`words = ["Let's", 'go', 'crazy', 'crazy', 'crazy', "'til", 'we', 'see', 'the', 'sun']`

| คำสั่ง 			  | output |
| -------			|--------|
| `words[0]`			| `"Let's"`	 |
| `words[1]`			| `'go'`	 |
| `words[-3]`			| `'see'`	 |
| `words[5]`			| `"'til"`	 |


`words[20]` จะทำให้เกิด `IndexError` เนื่องจากไม่มีสมาชิกอยู่ที่ index ที่ 20 

### การหั่นลิสต์ (List splicing)
เราจะใช้ operator `[]` และกฏการใช้ช่วงของ index ที่เหมือนกับสตริงทุกประการ

### `for` ลูปบนลิสต์
เราสามารถ iterate ไปบนลิสต์ ด้วยคำสั่งที่คล้ายคลึงกับสตริง 

สมมติว่าเราต้องการนับว่าลิสต์ของคำมีคำที่สะกดด้วยตัวเล็กทั้งหมด 
```python
word_list = ['Rick', 'and', 'Michonne', 'protect', 'Carl']
count = 0
for i in range(len(word_list)):
	word = word_list[i] # ลอกคำที่ index i เก็บใส่ตัวแปร
	if word.is_lower(): # เช็คว่าสะกดด้วยตัวเล็กหรือไม่ 
		count += 1
```
เราจะใช้ `i` เป็น index ในการเข้าถึงสมาชิกแต่ละตัวซึ่งจะเขยิบค่า 0 ไปเรื่อย ๆ จนถึง `len(word_list)` แต่ว่าการลูปด้วยวิธีนี้ ซึ่งเรียกว่าลูปไปบน index ไม่ค่อยสะดวกเท่าใดนัก เพราะต้องเรียก `len(word_list)` และต้องเข้าถึงสมาชิกของลิสต์แยกออกมาอีกคำสั่งนึง `word_list[i]` ในภาษาไพธอนเราสามารถ iterate ไปบนสมาชิกได้โดยตรงดังนี้
```python
word_list = ['Rick', 'and', 'Michonne', 'protect', 'Carl']
count = 0
for word in word_list:
	if word.is_lower(): # เช็คว่าสะกดด้วยตัวเล็กหรือไม่ 
		count += 1
```
โค้ดข้างบนนี้ได้ผลออกมาเหมือนกันทุกประการ แต่ว่าเราใช้การ iterate ไปบนสมาชิกแต่ละตัวตรงๆ ในการลูปรอบแรก `word` จะมีค่าเป็น `word_list[0]` ในการลูปรอบที่สอง `word` จะมีค่าเป็น `word_list[1]` และไปเรื่อย ๆ จนลูปครบทุกสมาชิกทุกตัวในลิสต์ จะเห็นได้ว่าเราประหยัดได้ค่อนข้างมาก โค้ดดูสะอาดตา และสะดวกสบายในการเขียนมากกว่าการ iterate บน index

แต่ในบางกรณีเราต้องการทราบด้วยว่าในลูปนี้เราอยู่ index ที่เท่าไรแล้ว ในกรณีนี้เราจะใช้คำสั่ง `enumerate` ตัวอย่างเช่น 
```python
word_list = ['Rick', 'and', 'Michonne', 'protect', 'Carl']
count = 0
for word_index, word in enumerate(word_list):
	if word.is_lower(): # เช็คว่าสะกดด้วยตัวเล็กหรือไม่ 
		count += 1
```
จากโค้ดข้างบน ในลูปรอบแรก ค่าของ `word_index` จะเท่ากับ 0 และค่าของ `word` จะเท่ากับ `'Rick'` เพราะฉะนั้นเราจะทราบด้วยว่าในแต่ละรอบเราอยู่ที่ index ใดแล้ว วิธีนี้มีประโยชน์มากเวลาประมวลผลแต่ละคำในประโยค และเราต้องพิจารณาด้วยว่าคำที่อยู่รอบ ๆ คือคำว่าอะไรบ้าง จึงจำเป็นต้องใช้ index มาควบคู่ด้วย

### List operator และ built-in function

ลิสต์ใช้ operator และ built-in function ที่คล้ายคลึงกับสตริง 

| Operator  		| ความหมาย 				  | ตัวอย่าง |
| --------  		| ---------				  | -------|
| + 				| ต่อลิสต์ (concatenate)		| `['a','a'] + ['b','b']` --> `['a','a','b','b']`| 
| * 				| ซ้ำลิสต์      				| `['a','b'] * 3` --> `['a','b','a','b','a','b']`| 
| `in`	    		| เช็คว่าข้อมูลชิ้นนี้อยู่ในลิสต์หรือไม่ 	| `'b' in ['a','b']` --> `True` |
|					|						   	|   `'c' in ['a','b']` --> `False`
| `not in`			| นิเสธของ `in`			  	|   `'b' not in ['a','b']` --> `False` |
| ==				| เท่ากันเป๊ะหรือไม่			| `['a','b'] == ['a','b']` --> `True` |
|					|							| `['a','b'] == ['a','b','c']`  --> `False` |
| `len(s)`			| return ความยาวลิสต์		 | `len(['a','b','c'])` --> 3 |

### การเขียนทับด้วย `[]`
````{sidebar} ตัวอย่าง
```python
accountant_list = ['เจ', 'เมย์', 'จอย', 'เมย์', 'เมย์', 'มิว']
accountant_list[0] = 'โจ้'
print(accountant_list)
# Output: ['โจ้', 'เมย์', 'จอย', 'เมย์', 'เมย์', 'มิว']
```
````
เราสามารถใช้ `[]` คร่อม index ที่เราต้องการเขียนทับ และใช้ `=` ในการให้ค่า (assignment) คล้าย ๆ กับการใช้ตัวแปร เราอาจจะคิดเสมือนว่าลิสต์เป็นการเก็บตัวแปรไว้หลาย ๆ ตัวแปร แบบเรียงลำดับกันตามที่เราต้องการ  

## เมท็อดของลิสต์
ลิสต์ของเมท็อดของไพธอน เวอร์ชัน 3.12 มีอยู่ 11 เมท็อด แต่ว่าเมท็อดที่ใช้บ่อย ๆ ในการประมวลผลข้อมูลที่เกี่ยวข้องกับวิทยาการข้อมูล และการประมวลผลภาษาธรรมชาติ มีอยู่ 8 เมท็อด ได้แก่ `.append() .extend() .sort() .index() .count() .insert() .pop() .remove()` นอกจากนั้นยังมีฟังก์ชันบิวอินที่ใช้กับลิสต์ได้ 4 ฟังก์ชัน ได้แก่ `sort() sum() max() min()` ซึ่งเราจะเรียนรู้วิธีการใช้เมท็อดและฟังก์ชันเหล่านี้ในบทนี้

### เพิ่มข้อมูลเข้าท้ายลิสต์: `.append()`
````{sidebar} ตัวอย่าง
```python
sales_list = [23, 12, 96] # สร้างลิสต์
sales_list.append(100) # เติมข้อมูลเข้าไป
print(sales_list) 
#Output คือ [23, 12, 96, 100]
```
````

Input: สมาชิกใหม่

Output: `None`

method นี้ใช้เพิ่มสมาชิกเข้าไปอีกหนึ่งตัวเข้าไปท้ายลิสต์ method นี้นับได้ว่าเป็น method ที่ใช้บ่อยที่สุดของลิสต์ มักจะใช้เมื่อเราสร้างลิสต์ขึ้นมาหนึ่งอันและต้องการเก็บผลลัพท์ที่ต้องการเติมเข้าไปเรื่อย ๆ ก่อนจะนำมาคำนวณ หรือนำผลออกมาดู 

### นำลิสต์หลาย ๆ อันมาต่อกัน: `.extend()`
````{sidebar} ตัวอย่าง
```python
sales_first_six_months = [23, 12, 96, 100, 40, 10]
sales_last_six_months = [33, 44, 55, 66, 77, 88]
sales_first_six_months.extend(sales_last_six_months)
print(sales_first_six_months)
# Output: [23, 12, 96, 100, 40, 10, 33, 44, 55, 66, 77, 88]
```
````
Input: ลิสต์ที่ต้องการ copy มาใส่

Output: `None`

method นี้ใช้สำหรับเวลาที่เราไม่อยากเรียก `.append` บ่อย ๆ ถ้าหากเรามีอีกลิสต์นึงที่เราต้องการ copy เอามา ให้เรียก method นี้ ซึ่งจะต้องรับลิสต์มาเป็น input เท่านั้น 

ข้อสังเกตที่สำคัญคือ method นี้ไม่ได้ย้ายสมาชิกจากอีกลิสต์ที่เป็น input method จะ copy สมาชิกทุกตัวออกมาจากอีกลิสต์ที่เป็น input

### เรียงลำดับสมาชิกในลิสต์: `sorted(list)` และ `.sort()`
````{sidebar} ตัวอย่าง
```python
sales_list = [23, 12, 96, 100]
sorted_sales_list = sorted(sales_list)
print(sorted_sales_list)
# Output: [12, 23, 96, 100]

accountant_list = ['เจ', 'เมย์', 'จอย', 'มิว']
accountant_list.sort()
print(accountant_list) # เรียงไม่ตรงตามหลักพจนานุกรม
# Output: ['จอย', 'มิว', 'เจ', 'เมย์']

```
````
การเรียงลำดับสมาชิกที่อยู๋ในลิสต์มีอยู่สองวิธี การเรียกฟังก์ชัน `sorted` หรือการให้ลิสต์เรียก method `.sort()`

`sorted` เป็นฟังก์ชันบิวท์อินที่รับลิสต์เป็น input และ return ลิสต์ใหม่อีกชุดที่สมาชิกทุกตัวถูกเรียงลำดับแล้ว ซึ่งหลังจากที่เรียกฟังก์ชัน `sorted` ลิสต์ที่เป็น input นั้นจะไม่ถูกเปลี่ยนแปลงแต่อย่างใด 

`.sort` เป็น method ของลิสต์ที่ไม่รับ input และไม่ return อะไรออกมา หลังจากที่ลิสต์ได้เรียก `.sort()` แล้วสมาชิกของลิสต์ที่เรียก method จะถูกเรียงตามลำดับ 

ข้อควรระวังเกี่ยวกับการเรียงลำดับคือ ฟังก์ชันและ method นี้จะเรียงลำดับสตริงภาษาไทยไม่ถูกต้องตามหลักพจนานุกรมไทย แต่จะเรียงโดยการเปรียบเทียบตัวอักษรตัวแรกก่อนว่ามาก่อนมาหลัง ถ้าเหมือนกันจะดูตัวอักษรต่อไปเรื่อย ๆ เพราะฉะนั้นจากตัวอย่าง `'เจ'` กับ `'เมย์'` มาทีหลังอีกสองชื่อเพราะว่า `เ` มาหลัง `จ` และ `ม`

### หาผลรวม ค่าสูงสุด ต่ำสุด ในลิสต์: `sum(list) max(list) min(list)`
````{sidebar} ตัวอย่าง
```python
class_size_list = [40, 50, 60, 70, 80]
print(sum(class_size_list))
# Output: 300
print(max(class_size_list))
# Output: 80
print(min(class_size_list))
# Output: 40
```
````
Input: ลิสต์ที่มีสมาชิกเป็นค่าที่จะนำมาคำนวณหาผลรวม หรือค่าสูงสุด หรือค่าต่ำสุด

Output: ผลรวม (`sum`) หรือค่าสูงสุด(`max`) หรือค่าต่ำสุด(`min`)

ข้อควรระวังคือฟังก์ชันเหล่านี้ไม่ใช่่ method แต่ว่าเป็นฟังก์ชันบิวท์อิน เพราะฉะนั้นลิสต์ไม่สามารถเรียก `.sum()` ได้ ถ้าหากเราเผลอเรียกประหนึ่งว่าเป็น method เราจะได้ `AttributeError` ซึ่งแจ้งให้เราทราบว่าลิสต์ไม่มี method ที่เราต้องการจะเรียก
```
>>> class_size_list.sum()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'list' object has no attribute 'sum'
```

### หา index ของสมาชิก: `.index()`
````{sidebar} ตัวอย่าง
```python
accountant_list = ['เจ', 'เมย์', 'จอย', 'มิว', 'จอย']
print(accountant_list.index('จอย'))
# Output: 2
```
````
Input: สมาชิกที่ต้องการทราบ index (ตำแหน่งบนลิสต์)

Output: index

ข้อควรระวัง
- ก่อนใช้ method นี้ต้องเตือนความจำตัวเองก่อนว่า index ของตำแหน่งแรกในลิสต์คือ 0 ในตัวอย่างนี้ `'เจ'` และ `'เมย์'` อยู่ index ที่ 0 และ 1 ตามลำดับ
- ถ้า input ปรากฏมากกว่าหนึ่งครั้ง method จะ return index ที่ต่ำกว่า ซึ่งก็คือตัวแรกที่เจอ ถ้ากวาดหาจากซ้ายไปขวาในลิสต์ 
- ถ้า input เป็นสิ่งที่ไม่ได้อยู๋ในลิสต์ เราจะได้  `ValueError` และเราจะได้รับแจ้งว่าค่าค่านั้นไม่ได้อยู่ในลิสต์ เช่น 
```
>>> accountant_list.index('จิว')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: 'จิว' is not in list
```

### นับจำนวนของสมาชิกที่ระบุมา: `.count()`
````{sidebar} ตัวอย่าง
```python
accountant_list = ['เจ', 'เมย์', 'จอย', 'เมย์', 'เมย์', 'มิว']
print(accountant_list.index('เมย์'))
# Output: 3
```
````
Input: สมาชิกที่ต้องการหาและนับ

Output: จำนวนที่เจอ

ถ้าหากสิ่งที่ต้องการนั้นไม่ปรากฏอยู่ในลิสต์ จะไม่ได้ `ValueError` แต่จะได้ 0 คืนกลับมาตามที่ควรจะเป็น

### แก้ไขลิสต์: `.insert() .pop() .remove()`
method เหล่านี้ถูกใช้บ้างเป็นบางครั้ง ข้อควรระวังคือ method เหล่านี้แก้ไขลิสต์โดยตรง โดยไม่ได้สร้างลิสต์ใหม่ขึ้นมา ทำให้ index ของสมาชิกทุกตัวเปลี่ยนไปหมด เพราะเวลาเราแทรกสมาชิกเข้ามา หรือนำสมาชิกออกไปทำให้ตำแหน่งของสมาชิกแต่ละตัวเลื่อนกันไปเป็นทอด ๆ เพราะฉะนั้นหากเราเรียก method เหล่านี้ใน `for` ลูปอาจจะทำให้เรางงว่าสมาชิกบางตัวถูกข้ามไปหรือไม่ และทำให้โค้ดอ่านทำความเข้าใจได้ยากขึ้น และยากต่อการแก้ไขหากเกิด error 

#### แทรกสมาชิกเข้าลิสต์: `.insert()`
````{sidebar} ตัวอย่าง
```python
accountant_list = ['เจ', 'เมย์', 'จอย', 'มิว']
accountant_list.insert(1, 'เจน')
print(accountant_list)
# ['เจ', 'เจน', 'เมย์', 'จอย', 'มิว']
```
````
Input: 1) index (สามารถใช้ negative index ได้) 2) สมาชิกใหม่

Output: `None` 

ถ้าหาก index สูงกว่าความยาวของลิสต์ สมาชิกใหม่จะไปนำต่อท้ายลิสต์ และจะไม่ให้โยน error กลับมา

#### นำสมาชิกออกจากลิสต์: `.remove()`
````{sidebar} ตัวอย่าง
```python
accountant_list = ['เจ', 'เมย์', 'จอย', 'มิว']
accountant_list.remove(2)
print(accountant_list)
# ['เจ', 'เมย์', 'มิว']
```
````
Input: ค่าที่ต้องการเอาออก

Output: `None` 

ลิสต์จะทำการหา input ในลิสต์ ถ้าหาพบก็จะนำสมาชิกทุกตัวที่มีค่านั้นออกไปจากลิสต์  ถ้าหาก input ไม่ได้ปรากฏอยู่ในลิสต์ python interpreter จะโยน `ValueError`

#### นำสมาชิกออกจากลิสต์: `.pop()`
````{sidebar} ตัวอย่าง
```python
accountant_list = ['เจ', 'เมย์', 'จอย', 'มิว']
removed_member = accountant_list.pop(2)
print(accountant_list)
# ['เจ', 'เมย์', 'มิว']
print(removed_member)
# จอย
```
````
Input: index (สามารถใช้ negative index ได้)

Output: สมาชิกที่เคยอยู่ที่ index นั้น 

ลิสต์จะ return สมาชิกที่อยู่ที่ index ที่กำหนดมาให้ จากนั้นก็จะดีดเอาสมาชิกตัวนั้นออกไป (method นี้เลยชื่อว่า pop ซึ่งแปลว่าดีดออก) ถ้าหาก index นั้นไม่ได้อยู่ในลิสต์ python interpreter จะโยน `IndexError` และแจ้งว่า index ไม่ได้อยู่ในช่วงที่เหมาะสม 


## ดิกชันนารี (Dictionary)
ดิกชันนารี (ซึ่งโปรแกรมเมอร์มักเรียกว่าดิกต์ (dict) เฉย ๆ) คือ โครงสร้างข้อมูลที่ไว้เก็บคู่ของ key และ value (key-value pair) จำนวนมาก ๆ จึงเรียกเปรียบเปรยว่าเหมือนพจนานุกรมซึ่งมี key เป็นคำที่เราต้องการหาความหมาย และ value เป็นควาหมายของคำแต่ละคำ พจนานุกรมจะสมบูรณ์ได้ก็ต่อเมื่อมีคู่ key (คำ) และ value (ความหมาย) จำนวนมาก ๆ ให้ครอบคลุมเกือบทุกคำในภาษา แต่ในไพธอนดิกชันนารีมีสามารถมี key เป็นอะไรก็ได้ และ value เป็นอะไรก็ได้เช่นกัน 

ข้อเหมือนอีกประการหนึ่งระหว่างดิกต์กับพจนานุกรม คือ เราใช้ดิกต์หรือพจนานุกรมเพื่อตอบคำถามว่า *คำนี้ มีความหมายว่าอะไร* แต่ไม่สามารถตอบคำถามว่า *ความหมายนี้ตรงกับคำว่าอะไร* เราสามารถเปิดหาว่าได้ว่า key ได้มานั้นอยู่คู่กับ value ตัวไหน ภาษาวิทยาการคอมพิวเตอร์มักเรียกว่าดิกต์เป็นการแมพจาก key ไปยัง value (key-value mapping)

ตัวอย่างการใช้ดิกต์ในการเก็บข้อมูล ได้แก่

|  	         			| key | value | 
|----------------------|----|--------|
| สมุดโทรศัพท์			| ชื่อ | เบอร์โทรศัพท์ |
| พจนานุกรมไทย-อังกฤษ	| คำศัพท์ภาษาไทย | ความหมายเป็นภาษาอังกฤษ | 
| ทะเบียน				| รหัสประจำตัวนิสิต | รายวิชาที่ลง | 
| ดัชนีท้ายเล่มหนังสือ		| คำสำคัญ | เลขหน้าที่มีคำนั้นอยู่ | 
| search engine		| คำ | หมายเลขของเอกสารที่มีคำนั้นอยู่  | 
| สถิติของคำ 		|  คำ  | จำนวนครั้งที่พบเจอคำนั้นในคลังข้อมูล | 

จากตัวอย่างแรกหากเราจัดเก็บสมุดโทรศัพท์ โดยให้ key เป็นชื่อ value เป็นเบอร์โทรศัพท์ เราจะไม่สามารถเปิดหาได้ว่าเบอร์ปริศนาที่ได้มานั้นเป็นเบอร์ของใคร 

จุดเด่นของดิกชันนารีคือสามารถเปิดหา (lookup) value จาก key ที่กำหนดให้ได้อย่างรวดเร็วที่สุด โดยไม่ต้องคำนึงว่าดิกชันนารีเก็บ key value ไว้ทั้งหมดกี่คู่ ภาษาวิทยาการคอมพิวเตอร์เรียกว่า ระยะเวลาคงตัว (constant time) ย้อนกลับไปตัวอย่างการจัดเก็บสมุดโทรศัพท์ ในตัวอย่างนี้ถ้าพูดกันให้ถูกต้องจริง ๆ เราสามารถเปิดหาได้ว่าเบอร์ปริศนาที่ได้มานั้นเป็นของใคร แต่ว่าเราจะต้องเปิดไล่หาทั้งสมุดโทรศัพท์ ถ้าเรามี key value อยู่เยอะคู่ ระยะเวลาที่โปรแกรมใช้ในการ lookup ก็เยอะตามไปด้วย ภาษาวิทยาการคอมพิวเตอร์เรียกว่าระยะเวลาเชิงเส้น (linear time) 

### การสร้างดิกชันนารีด้วย `{}`
ดิกชันนารีถูกสร้างได้ด้วยการใช้ `{}` ซึ่งห้ามใช้ `()` หรือ `[]` (ใช้สร้างลิสต์)
```python
my_first_dict = {}
```
ตัวแปร `my_first_dict` เป็นดิกต์เปล่าที่ไม่มีข้อมูลเก็บอยู่เลย

เราสามารถใช้ `{}` คร่อมข้อมูล key-value pair ที่ต้องการเก็บได้โดยตรง โดยใช้ไวยากรณ์ในการสร้างดังนี้
```python
ชื่อตัวแปร = {key1:value1, key2:value2, key3:value3, ..., keyn:valuen}
```
จับคู่ key และ value โดยใช้เครื่องหมาย `:` และแต่ละ key-value pair คั่นด้วยเครื่องหมาย `,` คล้ายๆ กับการสร้างลิสต์ที่ใช้ `,` ในการคั่นสมาชิกแต่ละตัว เช่น

```python
name_to_phone_number = {'ตังเม': '088-888-8888', 'เป่าหลง' : '099-999-9999', 
			 'เจนนี่': '011-111-1111'}
```
ดิกชันนารีเก็บข้อมูลดังนี้ 

| key | value |
|-----|-------|
|'ตังเม'| '088-888-8888'|
|'เป่าหลง'| '099-999-9999'|
|'เจนนี่'| '011-111-1111'|

### ชื่อตัวแปรที่เก็บดิกชันนารี
ชื่อตัวแปรที่เก็บดิกชันนารีควรจะบอกให้ชัดเจนว่า key คืออะไร และ value คืออะไร และคั่นด้วย `_to_` เพื่อเป็นการบ่งบอกว่าตัวแปรเก็บดิกชันนารี เช่น
`name_to_phone_number` หรือ `word_to_frequency` หรือ `student_id_to_name` เป็นต้น 
ถึงแม้ว่าชื่อตัวแปรไม่ได้มีผลต่อการทำงานของโปรแกรมแต่อย่างใด แต่เนื่องจากดิกต์เป็นโครงสร้างข้อมูลที่ค่อนข้างซับซ้อน เราจึงควรที่จะตั้งชื่อตัวแปรให้สื่อความหมายว่าเก็บข้อมูลอะไรอยู่ 

### หาจำนวนคู่ key-value ด้วยคำสั่ง `len`
คำสั่ง `len` เมื่อใช้กับดิกต์จะ return จำนวนคู่ของ key-value ที่อยู่ในดิก
```python
name_to_phone_number = {'ตังเม': '088-888-8888', 'เป่าหลง' : '099-999-9999',
	'เจนนี่': '011-111-1111'}
len(name_to_phone_number) #--> 3
```

### เพิ่มข้อมูล (คู่ key-value) เข้าดิกชันนารี
เมื่อเราสร้างดิกต์ขึ้นมาแล้วอันหนึ่งเราสามารถเพิ่มคู่ key value ได้ด้วยคำสั่ง `d[key] = value` โดย key จะเป็นสตริง หรือตัวเลขก็ได้ แต่ไม่สามารถใช้บูลีน หรือลิสต์มาเป็นคีย์ได้ เช่น 
```python
name_to_phone_number = {'ตังเม': '088-888-8888', 'เป่าหลง' : '099-999-9999',
	'เจนนี่': '011-111-1111'}
name_to_phone_number['โนโซมิ'] = '066-666-6666'
```
บรรทัดแรกเราสร้างดิกชันนารรีที่เก็บค่า key value ดังนี้
| key | value |
|-----|-------|
|'ตังเม'| '088-888-8888'|
|'เป่าหลง'| '099-999-9999'|
|'เจนนี่'| '011-111-1111'|

หลังจากรันบรรทัดที่ 2 ข้อมูลในดิกชันนารีจะกลายเป็น
| key | value |
|-----|-------|
|'ตังเม'| '088-888-8888'|
|'เป่าหลง'| '099-999-9999'|
|'เจนนี่'| '011-111-1111'|
|'โนโซมิ'|  '066-666-6666' |

ข้อควรระวังคือ key ที่อยู่ในดิกต์ห้ามซ้ำกัน ถ้าหากเราพยายามเพ่ิมคู่ที่มี key กับ key ที่เก็บอยู่ในดิกต์อยู่แล้ว คู่ key value เดิมจะถูกเขียนทับไปเช่น 
```python
name_to_phone_number = {'ตังเม': '088-888-8888', 'เป่าหลง' : '099-999-9999',
	'เจนนี่': '011-111-1111'}
name_to_phone_number['โนโซมิ'] = '066-666-6666'
name_to_phone_number['ตังเม'] = '011-222-3333'
```
หลังจากรันโค้ดนี้แล้ว ข้อมูลในดิกชันนารีมีดังต่อไปนี้

| key | value |
|-----|-------|
|'ตังเม'| '011-222-3333'|
|'เป่าหลง'| '099-999-9999'|
|'เจนนี่'| '011-111-1111'|
|'โนโซมิ'|  '066-666-6666' |

ดิกชันนารีมี key value อยู่ 4 คู่ เท่าเดิม  `name_to_phone_number['ตังเม'] = '011-222-3333'` ทำการเปลี่ยนคู่ key value ที่มี `'ตังเม'` เป็น key ให้เป็นค่าใหม่ที่ป้อนเข้าไป  ให้สังเกตด้วยว่าดิกชันนารีไม่ได้ลบคู่ key value เก่าและเติมคู่ใหม่เข้าไป ดิกชันนารีทำการเขียนทับตำแหน่งเดิม

### เข้าถึง value ด้วย key: `[]` และ `.get()`
เราสามารถระบุ key ที่เราต้องการทราบ value ได้ สมมติว่าเราต้องการทราบเบอร์โทรศัพท์ของตังเม จากดิกชันนารีที่เก็บหมายเลขโทรศัพท์ 
```python
name_to_phone_number = {'ตังเม': '088-888-8888', 'เป่าหลง' : '099-999-9999',
	'เจนนี่': '011-111-1111'}
name_to_phone_number['ตังเม'] # ---> '088-888-8888'
```
การเปิดหา value จาก key ที่ระบุเราเรียกว่าการเปิดหาข้อมูลในดิกชันนารี (dictionary lookup) ซึ่งแปลว่าเครื่องเก็บข้อมูลทุกอย่างไว้ในดิกชันนารีแล้ว ไม่ต้องไปตามมาหามาจากแหล่งอื่น สามารถเปิดหาแล้วเจอได้เลย 

ข้อควรระวังคือ ถ้าหากว่าเรา lookup จาก key ที่ไม่ได้มีอยู่ในดิกต์เราจะได้ `KeyError` คืนกลับมา
```
>>> name_to_phone_number = {'ตังเม': '088-888-8888', 'เป่าหลง' : '099-999-9999', 
...                      'เจนนี่': '011-111-1111'}
>>> name_to_phone_number['โนโซมิ']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'โนโซมิ'
```

ข้อควรระวังอีกประการคือ เราไม่สามารถ lookup จาก value เพื่อหา key ได้ เนื่องจากดิกชันนารีเก็บข้อมูลในลักษณะเราไปจาก key ไปสู่ value ได้ แต่ทำกลับกันไม่ได้ เครื่องจะให้ `KeyError` กลับมา
```
>>> name_to_phone_number['011-111-1111']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: '011-111-1111'
```

เพื่อป้องกันการเกิด `KeyError` เราสามารถใช้ `.get()` เพื่อ lookup แต่กำหนดค่าสำรองที่จะ return ได้ในกรณีที่ key นั้นไม่มีอยู่ในดิก
```
>>> word_to_freq = {'the': 50000, 'jump' : 200, 'Andy': 80}
>>> word_to_freq['Jack']
KeyError: 'Jack'
>>> word_to_freq.get('Jack')
None
>>> word_to_freq.get('Jack', 0)
0
```
บรรทัดที่สองคือการเปิดหา key `'laptop'` ในดิกต์ แต่ถ้าหากไม่เจอให้ return 0 ทำให้เราไม่ต้องเจอกับ `KeyError` 

### `for` ลูปบนดิกชันนารี
เราสามารถ for ลูปวนซ้ำไปบน key (iterate on keys) วนซ้ำไปบน value (iterate on values) หรือวนซ้ำไปบนคู่ key-value (iterate on key-value pairs) ขึ้นอยู่กับการใช้งาน โดยเราจะใช้ method `.keys() .values() .items()` ตามลำดับ ทั้ง 3 method นี้จะ return ค่าที่มี type เป็น *iterable* ซึ่งก็คือสิ่งที่เราสามารถ iterate ไปได้  

#### วนซ้ำไปบน key 
เราสามารถใช้ไวยากรณ์ของ `for` ลูปไปบนดิกชันนารี ซึ่งจะตีความไปว่าเราจะไล่เรียงไปบน key แต่ละตัว 
ตั้งแต่ Python 3.7 ขึ้นไป การลูปบนดิกชันนารี เครื่องจะไล่เรียงข้อมูล ออกมาจะเป็นลำดับเดียวกับตอนที่ใส่ข้อมูลเข้าไป 
```python
name_to_phone_number = {'ตังเม': '088-888-8888', 'เป่าหลง' : '099-999-9999',
	'เจนนี่': '011-111-1111'}
name_to_phone_number['โนโซมิ'] = '066-666-6666'
name_to_phone_number['ตังเม'] = '011-222-3333'
for name in name_to_phone_number: 
	print(name)
```
จะได้ผลออกมาคือ
```python
ตังเม
เป่าหลง
เจนนี่
โนโซมิ
```
สังเกตว่า `ตังเม` ถูกไล่เรียงออกมาเป็นอันดับแรก ถึงแม้ว่าจะถูกเขียนทับทีหลังก็ตาม โดยทั่วไปแล้วเราไม่ควรอาศัยให้ดิกชันนารีเรียงลำดับข้อมูลตามลำดับที่ข้อมูลถูกป้อนเข้าไป 

หรือถ้าหากให้โค้ดมีความกระจ่างขึ้นว่าเรากำลังวนซ้ำไปบน key สามารถใช้ method `.keys()` เช่น
```python
for name in name_to_phone_number.keys(): 
	print(name)
```

แต่ถ้าหากต้องการเก็บ key ทั้งหมดไว้ในลิสต์แยกออกมาให้ใช้คำสั่ง `list()` เป็นการแปลง type จาก iterable ให้เป็นลิสต์ดังนี้

```
name_list = list(name_to_phone_number.keys())
```

#### วนซ้ำไปบน value
ดิกชันนารีมี method `.values()` ที่ทำให้เราวนซ้ำไปบน value ได้
```python
name_to_phone_number = {'ตังเม': '088-888-8888', 'เป่าหลง' : '099-999-9999',
	'เจนนี่': '011-111-1111'}
name_to_phone_number['โนโซมิ'] = '066-666-6666'
for number in name_to_phone_number.values():
	print(number)
```
จะได้ผลออกมาคือ
```
088-888-8888
099-999-9999
011-111-1111
066-666-6666
```
ลำดับที่ปรากฏเหมือนกันกับการวนซ้ำไปบน key 

method `.values()` ให้ค่าเป็น iterable เช่นกัน เพราะฉะนั้นเราสามารถเก็บเอา value ทั้งหมดใส่ลิสต์โดยการแปลง type ให้เป็นลิสต์ด้วยคำสั่ง `list()`

```
phone_numbers = list(name_to_phone_number.values())
```

#### วนซ้ำไปบนคู่ key-value

```python
for name, number in name_to_phone_number.items():
	print(name)
	print(number)
```
จะได้ผลออกมาคือ
```
ตังเม
088-888-8888
เป่าหลง
099-999-9999
เจนนี่
011-111-1111
โนโซมิ
066-666-6666
```

### ตรวจสอบว่ามี key นั้นอยู่ในดิกต์หรือไม่: `in`
เราสามารถตรวจสอบว่า key ที่เราต้องการหามีอยู่ในดิกต์อยู่แล้วหรือไม่ 

```python
word_to_freq = {'the': 50000, 'jump' : 200, 'Andy': 80}
'Jack' in word_to_freq #---> False
```

การตรวจสอบว่า value อยู่ในดิกต์หรือไม่ทำได้ค่อนข้างลำบากเราจะต้อง `for` ลูปวนไปบน value ทั้งหมดเพื่อหาเอง  เช่น ถ้าเราอยากทราบว่าค่า `200` เป็น value ที่อยู่ในดิกต์หรือไม่ 
```python
value_to_find = 200
word_to_freq = {'the': 50000, 'jump' : 200, 'Andy': 80}
for freq in word_to_freq.values():
	if value_to_find == freq:
		return True
return False
```
หรือนำ value เข้าลิสต์ก่อนแล้วค่อยใช้ `in` ในการตรวจสอบ
```python
value_to_find = 200
word_to_freq = {'the': 50000, 'jump' : 200, 'Andy': 80}
freq_list = list(word_to_freq.values())
return value_to_find in freq_list
```
ซึ่งทั้งสองวิธีเป็นมักจะใช้เวลานานเนื่องจากเราจะต้องวนไล่ไปบน value แต่ละตัว ยิ่งดิกชันนารีใหญ่แค่ไหนเวลาในการรันโปรแกรมก็จะนานตามไปด้วย ซึ่งต่างจากการตรวจสอบ key ซึ่งใช้เวลาในการรันโปรแกรมเป็นค่าคงตัว ไม่ขึ้นกับขนาดของดิกชันนารี ถ้าหากเราจำเป็นต้องมีการตรวจสอบว่ามี value อะไรอยู่หรือไม่ เราไม่ควรใช้ดิกต์ในการ

### ลบคู่ key-value: `.pop`
เราสามารถลบคู่ key-value โดยการระบุ key ไม่สามารถลบโดยการระบุ value ได้
```python
word_to_freq = {'the': 50000, 'jump' : 200, 'Andy': 80}
word_to_freq.pop('the')
print(word_to_freq)
```
จะได้ผลออกมาคือ
```python
{'jump': 200, 'Andy': 80}
```


## ทูเปิล (tuple) 
ทูเปิล เป็นโครงสร้างข้อมูลที่เก็บข้อมูลเป็นลำดับคล้ายกับลิสต์ ลิสต์สามารถทำทุกอย่างที่ทูเปิลสามารถทำได้ การสร้างทูเปิลคล้ายคลึงกับการสร้างลิสต์แต่ว่าเราจะใช้วงเล็บ `()` แทนวงเล็บเหลี่ยม `[]` เช่น
```python
first_last_name = ('อรรถพล', 'ธำรงรัตนฤทธิ์')
```

ข้อแตกต่างคือ ทูเปิลเป็นโครงสร้างข้อมูลที่เปลี่ยนแปลงไม่ได้ (immutable) เมื่อเราสร้างทูเปิลขึ้นมาแล้ว ไม่สามารถเปลี่ยนแปลงสมาชิกที่อยู่ภายในได้ รวมถึงไม่สามารถเพิ่มสมาชิกเข้าไปได้ ทั้งหมดนี้ดูเหมือนจะเป็นข้อเสียของทูเปิล แต่ว่าการใช้ทูเปิลทำให้เกิดข้อผิดพลาดในโปรแกรมน้อยลง 
การใช้ทูเปิลเป็นการสื่อความหมายในโปรแกรมว่าแต่ละ index ของทูเปิลมีความหมายเจาะจง เช่น

- พิกัดบนแผนที่โลก อาจจะถูกเก็บในทูเปิดโดยที่ index 0 เป็น latitude และ index 1 เป็น longtitude อาจจะถูกเก็บในทูเปิล ดังนี้  `('13.7563° N', '100.5018°')`
- ชื่อนามสกุล อาจจะถูกเก็บในทูเปิลโดยที่ index 0 เป็นชื่อ index 1 เป็นนามสกุล ดังนี้ `('อรรถพล', 'ธำรงรัตนฤทธิ์')`
- สี มักจะถูกจัดเก็บเป็นค่าแดงเขียวน้ำเงิน (RGB) โดยที่ index 0 เป็นค่าของสีแดง index 1 เป็นค่าของสีเขียว index 2 เป็นค่าของสีน้ำเงิน ดังนี้ `(256, 256, 256)`

ในกรณีดังกล่าวทั้งหมดนี้เราไม่ควรจะเพิ่มสมาชิกเข้าไปในทูเปิลอีกแล้ว เพราะว่าพิกัดจะต้องมี 2 ตำแหน่งเท่านั้น ชื่อนามสกุลควรจะต้องถูกแทนด้วยทูเปิลแบบสองตำแหน่ง ค่าสีแบบ RGB ก็ต้องมีสีสามค่าเท่านั้น การเพิ่มสมาชิกเข้าไปทำให้สูญเสียความหมายของสิ่งที่ทูเปิลจะเก็บไว้

การเข้าถึงข้อมูลในทูเปิลใช้วิธีเดียวกับลิสต์ทุกประการ สามารถใช้ positive index และ negative index ได้เหมือนกันหมด 
```python
first_last_name = ('อรรถพล', 'ธำรงรัตนฤทธิ์')
first_name = first_last_name[0]
last_name = first_last_name[1]
print (first_name)
print (last_name)
```
เพื่อความสะดวกเรามักจะ*กระจาย*ค่าของทูเปิลใส่ตัวแปรหลาย ๆ ตัวพร้อม ๆ กัน เช่น 
```python
first_last_name = ('อรรถพล', 'ธำรงรัตนฤทธิ์')
first_name, last_name = first_last_name
print (first_name)
print (last_name)
```
การกระจายค่าที่จริงแล้วสามารถทำกับลิสต์ก็ได้ แต่ว่าไม่กรณีที่จะให้ใช้เนื่องจากเวลาเราเขียนโค้ดในการกระจายค่าเข้าสู่ตัวแปร เราจำเป็นต้องรู้ว่าลิสต์หรือทูเปิลนั้นมีจำนวนสมาชิกกี่ตัว ลิสต์เป็นโครงสร้างข้อมูลที่เราสามารถเปลี่ยนแปลงค่าข้างในได้ ทำให้เราไม่แน่ใจว่าข้อมูลในลิสต์มีอยู่กี่ตัว เมื่อเรามาถึงส่วนของโค้ดที่ต้องทำการกระจายข้อมูล แต่ว่าทูเปิลไม่มีปัญหานี้ เวลาเราสร้างทูเปิล เรามั่นใจได้เลยว่าค่าของทูเปิล และจำนวนสมาชิกของทูเปิลจะไม่เปลี่ยน 

ทูเปิลมี method `.count .index` เช่นเดียวกับลิสต์ และสามารถหั่นเป็นทูเปิลย่อยได้เหมือนกับลิสต์เช่นกัน แต่ว่ามักจะไม่ค่อยได้ใช้ประโยชน์ เพราะทูเปิลมีโครงสร้างตายตัว และข้อมูลที่อยู่ในแต่ละตำแหน่งเก็บข้อมูลคนละชนิดกันหมด 

## เคาน์เตอร์ (counter)
เคาน์เตอร์ เป็น*ซับคลาส (subclass)* ของดิกชันนารี ซึ่งแปลว่าเคานเตอร์สามารถทำได้เกือบทุกอย่างที่ดิกชันนารีสามารถทำได้ และยังมี method อื่น ๆ เพิ่มเติม 

เคาน์เตอร์เป็นดิกชันนารีที่ key เป็นอะไรก็ได้ แต่ว่า value จะต้องเป็นตัวเลข เท่านั้น จุดประสงค์หลักของการใช้โครงสร้างข้อมูลชนิดนี้คือเพื่อเก็บจำนวนครั้งที่พบ key แต่ละอัน 

เคาน์เตอร์ไม่ใช่ *บิวท์อินคลาส (built-in class)* ก่อนจะใช้จะต้อง `import` เข้ามาก่อนที่จะเรียกใช้ เคาน์เตอร์เป็นคลาสที่เป็นส่วนหนึ่งของโมดูล `collections` 

### การสร้างเคาน์เตอร์ว่าง ๆ
ใช้คำสั่ง `Counter()` ในการสร้างเคาน์เตอร์ซึ่งเป็นคำสั่งที่ต้อง `import` เข้ามาก่อน
```python
from collections import Counter
word_count = Counter()
```
### การสร้างเคาน์เตอร์จากดิกชันนารี
เราสร้างแปลงดิกชันนารีที่ value เป็นตัวเลขมาเป็นเคาน์เตอร์ได้ดังนี้
```python
word_count = Counter({'b':1, 'a':3, 'c':1})
```

### การสร้างเคาน์เตอร์จากลิสต์
การสร้างเคาน์เตอร์ คือ การใช้เคาน์เตอร์สามารถนับค่าต่าง ๆ ที่เก็บอยู่ในลิสต์ และจัดเก็บให้ค่าทั้งหมดเป็น key และจำนวนครั้งที่พบให้เก็บเป็น value 
```python
letter_list = ['a', 'b', 'c', 'a','b', 'a']
letter_count = Counter(letter_list)
letter_count['a'] #--> 3
letter_count['b'] #--> 2
letter_count['c'] #--> 1
```

### key ที่ไม่ได้อยู่ในเคาน์เตอร์ value จะเป็น 0
เมื่อเวลาเราเปิดหาค่า key ที่ไม่ได้มีอยู่ในเคาน์เตอร์ค่าที่ได้คืนมาจะเป็น 0 เสมอ ซึ่งต่างจากดิกชันนารีที่จะโยน `KeyError` กลับมา
```python
letter_count['d'] #--> 0
```
ฟีเจอร์นี้ทำให้เราใช้เคาน์เตอร์ได้สะดวกมากขึ้น เมื่อเราต้องการถามว่าค่าอะไรเจอกี่ครั้งบ้าง ถ้าค่าที่ไม่เจอเลยค่าที่ได้กลับคืนมาก็ควรจะเป็น 0 นอกจากนั้นแล้วเราสามารถอัพเดทเคาน์เตอร์ได้โดยไม่จำเป็นต้องตรวจสอบก่อนว่า key นั้นเคยมีอยู่ในเคาน์เตอร์แล้วหรือยัง เช่น สมมติว่าเราต้องการนับแค่คำที่ไม่มีตัวเลขปะปนอยู่เลยที่จัดเก็บอยู่ในลิสต์ `word_list`
```python
word_counter = Counter()
for word in word_list:
    if word.isalpha():
        word_counter[word] = word_counter[word] + 1
```
`word_counter[word]` ค่าเป็น 0 ถ้าเราไม่เคยเห็นคำนั้นมาก่อนซึ่งทำให้ expression ทางขวามือของเครื่องหมายเท่ากับเป็น `0 + 1` ซ่ึงเป็นผลที่เราต้องการ 
ถ้าหากเราจะใช้ดิกชันนารีก็สามารถทำได้ 
```python
word_counter = {}
for word in word_list:
    if word.isalpha():
        if word not in word_counter:
            word_counter[word] = 0
        word_counter[word] = word_counter[word] + 1
```
แต่เราต้องตรวจสอบว่า key อยู่ในดิกอยู่แล้วหรือไม่ ถ้าไม่ได้อยู่ต้องทำการตั้งคู่ key-value ใหม่โดยตั้งให้ค่า value เป็น 0 เตรียมเอาไว้ก่อน เพื่อป้องกัน `KeyError` 

### หาค่า key ที่คู่กับ value ที่สูงที่สุด: `.most_common()`
เคาน์เตอร์มี method ที่ไว้สำหรับ key ที่พบบ่อยที่สุด 
```python
letter_list = ['a', 'b', 'c', 'a','b', 'a']
letter_count = Counter(letter_list)
letter_count.most_common() #--> [('a', 3), ('b', 2), ('c', 1)]
letter_count.most_common(1) #--> [('a', 3)]
```
method นี้มี optional parameter ที่เราจะระบุหรือไม่ระบุก็ได้ว่าจะ return ผลกี่อันดับแรก ถ้าไม่ระบุจะให้ผลอย่างมาก 20 อันดับแรก สิ่งที่ method return มาให้คือลิสต์ของทูเปิล ทูเปิลที่ได้มาเป็นคู่ของ key-value เรียงลำดับตาม value 

## เซ็ต (Set)

เซ็ต เป็นโครงสร้างข้อมูลที่เก็บข้อมูลที่ไม่ซ้ำกัน และไม่มีลำดับ ซึ่งล้อกับเซ็ตในคณิตศาสตร์ เซ็ตมีความคล้ายคลึงกับลิสต์ คือ สามารถเก็บข้อมูล และเรียกใช้ข้อมูลที่เก็บเอาไว้ได้ แต่ข้อแตกต่างที่สำคัญ ได้แก่

1. เซ็ตไม่เก็บลำดับของข้อมูล เพราะฉะนั้นเราไม่สามารถใช้ `[index]` ในการเข้าถึงข้อมูลได้ ไม่สามารถใช้ `[]` ในการหั่นเซ็ตได้ ถึงแม้เราสามารถใช้ `for` ในเพื่อเข้าถึงสมาชิกในเซ็ตได้ แต่ว่าลำดับการไล่สมาชิกแต่ละตัวจะไม่ตรงกับลำดับที่เราเพิ่มสมาชิกเข้าไปในเซ็ต

2. เซ็ตไม่เก็บสมาชิกที่ซ้ำกัน ถ้าเราเพิ่มสมาชิกที่มีอยู่แล้วในเซ็ต สมาชิกที่เพิ่มเข้าไปจะไม่ถูกเก็บ และเซ็ตจะไม่แสดง error หรือเกิดข้อผิดพลาดใดๆ ขึ้น

3. การตรวจสอบว่าสมาชิกอยู่ในเซ็ตหรือไม่ ทำได้เร็วกว่าการตรวจสอบในลิสต์ เนื่องจากเซ็ตไม่เก็บลำดับข้อมูล ทำให้อัลกอริทึมในการตรวจสอบการเป็นสมาชิกดำเนินไปได้อย่างรวดเร็ว 

### การสร้างเซ็ต และการหาขนาดของเซ็ต

เซ็ตถูกสร้างขึ้นได้โดยการใช้ `{}` หรือคำสั่ง `set()` ถ้าต้องการสร้างเซ็ตว่าง สามารถใช้ `{}` หรือคำสั่ง `set()` ได้เลย ดังตัวอย่างต่อไปนี้

```python
basket = {}
basket = set()
```

หากต้องการสร้างเซ็ตแบบเป็นค่าคงที่ (literal) กล่าวคือสมาชิกของลิสต์ถูกระบุเอาไว้โดยตรงในโค้ด 
เราสามารถใช้ `{}` ในการสร้างเซ็ต และใส่สมาชิกที่ต้องการเก็บในเซ็ตลงไปใน `{}` ซึ่งสมาชิกแต่ละตัวจะต้องคั่นด้วย `,` และสมาชิกที่ซ้ำกันจะถูกเก็บเพียงตัวเดียว ดังตัวอย่างต่อไปนี้

```python
basket = {'apple', 'orange', 'apple', 'orange', 'banana'}
basket # เก็บแค่ {'orange', 'banana', 'apple'}
```

หากใช้คำสั่ง `set` ในการสร้างเซ็ต จะต้องใส่ลิสต์หรือสตริงที่ต้องการเก็บในเซ็ตลงไปใน `set()` ดังตัวอย่างต่อไปนี้

```python
basket = set(['apple', 'orange', 'apple', 'orange', 'banana'])
basket # เก็บแค่ {'orange', 'banana', 'apple'}
```
เพราะฉะนั้นเราสามารถใช้เซ็ตในการเปลี่ยนสมาชิกในลิสต์ให้เหลือแต่สมาชิกที่ไม่ซ้ำกันได้ โดยการเปลี่ยนลิสต์ให้เป็นเซ็ตด้วยคำสั่ง `set` และนำผลลัพท์ที่ได้เปลี่ยนกลับให้เป็นลิสต์ด้วยคำสั่ง `list` ดังตัวอย่างต่อไปนี้

```python
fruits = ['apple', 'orange', 'apple', 'orange', 'banana']
fruit_set = set(fruits)
fruit_list_no_duplicate = list(fruit_set)
```

วิธีการหาขนาดของเซ็ต (หรือจำนวนสมาชิกของเซ็ต) คล้ายคลึงกับการหาขนาดของลิสต์ และการหาขนาดของดิกชันนารี เราใช้ `len()` ในการหาขนาดของเซ็ตได้ ดังตัวอย่างต่อไปนี้

```python
basket = {'apple', 'orange', 'apple', 'orange', 'banana'}
len(basket) # 3
```

### การสร้างเซ็ตด้วย set comprehension
set comprehension คือ วิธีการสร้างเซ็ตที่ใช้คำสั่งแบบกระชับ และสร้างเซ็ตขึ้นมาโดยใช้เวลาน้อยกว่าการสร้างเซ็ตโดยวิธีอื่น ๆ   set comprehension คล้ายคลึงกับ list comprehension ตรงที่เราเริ่มจากแปลงข้อมูลจากลิสต์ ดิกชันนารี หรือเซ็ตอื่นๆ ให้กลายเป็นเซ็ต (แทนที่จะเป็นลิสต์) 

โครงสร้างของการสร้างเซ็ตด้วย set comprehension คล้ายกับ list comprehension เพียงแต่เราเปลี่ยน `[]` เป็น `{}` แทน ดังนี้
```python
{นิพจน์ (expression) for ไอเท็ม in ลิสต์ เซ็ต หรือดิกชันนารี if เงื่อนไข}
```
- นิพจน์ (expression) คือสูตรหรือคำสั่งที่ใช้แปลงไอเท็มแต่ละไอเท็มในลิสต์ เซ็ต หรือดิกชันนารี ให้กลายเป็นสมาชิกของเซ็ตที่เรากำลังสร้างขึ้น
- เงื่อนไขการเข้าสู่เซ็ต (มีหรือไม่มีก็ได้) เป็นสูตรที่แปลงไอเท็มให้เป็นบูลีน ถ้าบูลีนเป็น `True` ไอเท็มจะถูกเพิ่มเข้าไปในเซ็ตที่กำลังสร้างขึ้น แต่ถ้าบูลีนเป็น `False` ไอเท็มจะไม่ถูกเพิ่มเข้าไปในเซ็ตที่กำลังสร้างขึ้น

สมมติว่าเราต้องการสร้างเซ็ตของชื่อนักเรียนที่ลงท้ายด้วยสระอาจากลิสต์รายชื่อนักเรียน
```python
student_names = ['อาทิตยา', 'วิภา', 'อรรถพล', 'วิภา', 'คริส', 'สุชาดา']
aa_name_set = {name for name in student_names if name.endswith('า')}
```
เราสามารถใช้ set comprehension ในการสร้างเซ็ตของชื่อนักเรียนที่ลงท้ายด้วยสระอาได้ด้วยคำสั่งบรรทัดเดียว โครงสร้างของคำสั่ง set comprehension แบ่งเป็นสามส่วนดังนี้
- expression ไม่มีการเปลี่ยนแปลงชื่อนักเรียน แต่เราใช้ `name` ในการเข้าถึงชื่อนักเรียนแต่ละคน
- ไอเท็มเป็นชื่อที่ได้จากการใช้ `for` ในการวนลูปเพื่อเข้าถึงชื่อนักเรียนทุกคนในลิสต์ `student_names`
- เงื่อนไขการเข้าสู่เซ็ต เราใช้ `name.endswith('า')` ในการตรวจสอบว่าชื่อนักเรียนลงท้ายด้วยสระอาหรือไม่ ถ้าลงท้ายด้วยสระอา ชื่อนักเรียนจะถูกเพิ่มเข้าไปในเซ็ตที่กำลังสร้างขึ้น แต่ถ้าไม่ลงท้ายด้วยสระอา ชื่อนักเรียนจะไม่ถูกเพิ่มเข้าไปในเซ็ตที่กำลังสร้างขึ้น

### การตรวจสอบการเป็นสมาชิกโดยใช้ `in`
เราสามารถตรวจสอบว่าข้อมูลที่ได้มาเป็นสมาชิกของเซ็ตหรือไม่ โดยใช้ `in` ได้ ดังตัวอย่างต่อไปนี้

```python
languages = {'French', 'English', 'German', 'Chinese'}
'English' in languages # True
'Thai' in languages # False
```

เซ็ตสละความสามารถในการเก็บลำดับของข้อมูล เพื่อแลกมากับความเร็วในการหาข้อมูล (lookup) ในเซ็ต อัลกอริทึมหลังบ้านของ operator `in` ของลิสต์จะต้องไล่สมาชิกทีละตัว จนกว่าจะเจอสมาชิกที่ต้องการ หรือจนกว่าจะไล่สมาชิกทุกตัวแล้ว ซึ่งในกรณีที่สมาชิกมีจำนวนมาก ในทางตรงกันข้ามอัลกอริทึมหลังบ้านของ operator `in` ใช้อัลกอริทึมที่เรียกว่าแฮชชิง (hashing) ซึ่งใช้เวลาคงที่ ไม่ขึ้นกับจำนวนของสมาชิกที่อยู่ในเซ็ต  ทำให้เซ็ตเป็นโครงสร้างข้อมูลที่เหมาะสมกับการตรวจสอบการเป็นสมาชิกกว่าลิสต์

### for loop ในเซ็ต
เราสามารถใช้ `for` ในการวนลูปเพื่อเข้าถึงสมาชิกทุกตัวในเซ็ตได้ เหมือนกับการทำ `for` บนลิสต์ แต่เมื่อเซ็ตไม่มีการเก็บลำดับของสมาชิกไว้ การไล่ด้วย `for` จึงไม่ได้ไล่ไปตามลำดับของสมาชิกว่าตัวไหนถูกใส่เข้ามาก่อน ใส่เข้ามาทีหลัง 
```python
languages = {'French', 'English', 'German'}
for language in languages:
    print(language)
```
ผลลัพธ์ที่ print ออกมาคือ
```
German
English
French
```
ถึงแม้ผลลัพธ์ออกมาจะดูเหมือนว่าเซ็ตเก็บข้อมูลโดยเรียงลำดับตามพจนานุกรม แต่ว่าเราไม่สามารถการันตีได้ว่าจะได้ลำดับตามพจนานุกรมเสมอไป เพราะโดยคำนิยามแล้วสมาชิกในเซ็ตไม่มีการจัดลำดับใด ๆ ทั้งสิ้น ไพธอนเวอร์ชันต่อไปอาจจะไม่ได้แสดงผลลัพธ์ออกมาเรียงลำดับตามพจนานุกรมอย่างที่เห็นในเวอร์ชันนี้ (3.11) ก็เป็นได้

### การเพิ่มสมาชิกในเซ็ตด้วย `add()` 
เราสามารถเพิ่มสมาชิกในเซ็ตได้โดยใช้คำสั่ง `add` ซึ่งต่างจากคำสั่ง `append` ของลิสต์ คำว่า append ภาษาอังกฤษแปลว่าเพิ่มไปตรงท้าย แต่คำว่า add แปลว่าเพิ่มเข้าไปโดยไม่ได้คำนึงถึงลำดับของสมาชิก ผู้พัฒนาภาษาไพธอนเลือกใช้คำว่า add เพื่อแสดงให้เห็นว่าเซ็ตไม่เก็บลำดับของสมาชิก 

#### ตัวอย่าง
สมมติว่าเราทำโจทย์เดียวกับตัวอย่างที่ผ่านมา เราต้องการสร้างเซ็ตของชื่อนักเรียนที่ลงท้ายด้วยสระอาจากลิสต์รายชื่อนักเรียน เราสามารถใช้คำสั่ง `add` เพื่อเพิ่มสมาชิกที่ต้องการเข้าไปทีละตัว แทนที่การใช้ set comprehension ได้ดังนี้

```python 
student_names = ['อาทิตยา', 'วิภา', 'อรรถพล', 'วิภา', 'คริส', 'สุชาดา']
aa_name_set = {} # จะใช้ aa_name_set = set() แทนก็ได้
for name in student_names:
    if name.endswith('า'):
        aa_name_set.add(name)
```

### เอาสมาชิกออกจากเซ็ตด้วย `remove()`
คำสั่งนี้อาจจะเป็นคำสั่งที่ใช้ไม่ได้บ่อยนัก แต่เราควรรู้ไว้เพื่อความสมบูรณ์ของเนื้อหา คำสั่ง `remove` ใช้ในการลบสมาชิกออกจากเซ็ต โดยเราต้องระบุสมาชิกที่ต้องการลบออกไป ดังตัวอย่างต่อไปนี้

#### ตัวอย่าง
สมมติว่ามีคำตอบในแบบสอบที่มีตัวเลือก 5 ตัวเลือก คือ Strongly disagree, Disagree, Neutral, Agree, Strongly agree และเราต้องการลบตัวเลือก Strongly disagree และ Strongly agree ออกจากเซ็ตของตัวเลือกที่เป็นไปได้

```python
possible_responses = {'Strongly disagree', 'Disagree', 'Neutral', 'Agree', 'Strongly agree'}
possible_responses.remove('Strongly disagree')
possible_responses.remove('Strongly agree')
```

### Set operation: intersection union และการลบกันของเซ็ต
เซ็ตในภาษาไพธอนรองรับ set operation ทุกตัว สมมติว่าเรามีเซ็ต A เก็บอยู่ในตัวแปร `setA` และเซ็ต B เก็บอยู่ในตัวแปร `setB`

- intersection (A ∩ B) คือ การสร้างเซ็ตที่ประกอบด้วยสมาชิกที่อยู่ทั้งในเซ็ต A และเซ็ต B ภาษาไพธอนใช้คำสั่ง `setA.intersection(setB)`
- union (A ∪ B) คือ การสร้างเซ็ตที่ประกอบด้วยสมาชิกที่อยู่ในเซ็ต A หรือเซ็ต B อย่างน้อยหนึ่งเซ็ต ภาษาไพธอนใช้คำสั่ง `setA.union(setB)`
- การลบกันของเซ็ต (A - B) คือ การสร้างเซ็ตที่ประกอบด้วยสมาชิกที่อยู่ในเซ็ต A แต่ไม่อยู่ในเซ็ต B ภาษาไพธอนใช้คำสั่ง `setA - setB` หรือ `setA.difference(setB)`

เซ็ตในโลกของการประมวลผลภาษาธรรมชาติมักจะใช้ในการเก็บรายการคำศัพท์ (vocabulary หรือ vocab) เช่น คำศัพท์ที่ปรากฏทั้งหมดในข้อสอบชุดหนึ่ง คำศัพท์ที่เห็นทั้งหมดในคลังข้อมูล (corpus ชุดข้อมูลที่รวบรวมข้อมูลภาษาเอาไว้จำนวนมาก) คำศัพท์ที่แบบจำลองเข้าใจความหมายอยู่แล้ว เซ็ตเหมาะแก่การเก็บ vocabulary เพราะ vocabulary ประกอบด้วยคำศัพท์พบเห็นอย่างน้อยหนึ่งครั้ง โดยไม่คำนึงว่าเกิดขึ้นซ้ำหรือไม่ และไม่คำนึงถึงลำดับการเกิดของคำศัพท์ นอกจากนั้นแล้วเซ็ตในภาษาไพธอนยังรองรับการใช้ set operation ได้อย่างสะดวกสบายอีกด้วย 

ตัวอย่างข้างล่างนี้สมมติว่ามี vocabulary ที่ใหญ่มากซึ่งได้มาจากแบบจำลองภาษาขนาดใหญ่ ครอบคลุมหลายภาษาเก็บอยู่ในตัวแปร `multilingual_vocab` และมี vocabulary ที่มาจากแบบจำลองของภาษาไทยภาษาเดียว เก็บอยู่ในตัวแปร `thai_vocab` 

#### ตัวอย่าง: intersection
สมมติว่าเราต้องการหาว่าคำศัพท์คำใดบ้างที่ปรากฏในทั้งสองเซ็ต คือ `multilingual_vocab` และ `thai_vocab` สามารถใช้คำสั่ง `intersection` ในการหาคำศัพท์ที่ปรากฏในทั้งสองตัวแปรได้ดังนี้

```python
multilingual_vocab = {'hello', 'สวัสดี', '你好', 'สวัสดี', 'สวัสดี', 'สวัสดี'}
thai_vocab = {'สวัสดี', 'ขอบคุณ'}
multilingual_vocab.intersection(thai_vocab) # {'สวัสดี'}
```
หลังจากรันโค้ดแล้วลอง `print` ค่าที่ปรากฏอยู่ในตัวแปรจะได้ผลดังนี้
```python
print(multilingual_vocab)
```
output ที่ปรากฏบนหน้าจอ คือ
``` {'你好', 'สวัสดี', 'hello'}```

```python
print(thai_vocab)
```
output ที่ปรากฏบนหน้าจอ คือ
``` {'ขอบคุณ', 'สวัสดี'}```
คำสั่ง `intersection` คืนค่าเป็นเซ็ตใหม่ขึ้นมาต่างหาก แยกต่างหากจาก `multilingual_vocab` และ `thai_vocab` ที่เราใช้ในการเรียกคำสั่ง หลังจากเรียกคำสั่ง set operation แล้ว สมาชิกของ `multilingual_vocab` และ `thai_vocab` จะไม่เปลี่ยนแปลง

เพราะฉะนั้นที่ถูกต้องคือ ต้องเก็บค่าที่คืนมาจากคำสั่งไว้ในตัวแปรใหม่ 
```python
multilingual_vocab = {'hello', 'สวัสดี', '你好', 'สวัสดี', 'สวัสดี', 'สวัสดี'}
thai_vocab = {'สวัสดี', 'ขอบคุณ'}
overlapping_vocab = multilingual_vocab.intersection(thai_vocab) # {'สวัสดี'}
```
หากเราต้องการทราบจำนวนสมาชิกของแต่ละเซ็ต สามารถใช้ `len()` ในการหาได้ ดังตัวอย่างต่อไปนี้
```python
print(len(multilingual_vocab)) 
print(len(thai_vocab)) 
print(len(overlapping_vocab)) 
```
output ที่จะปรากฏบนหน้าจอ คือ 
```python
4
2
1
```

#### ตัวอย่าง: union
สมมติว่าเราต้องการขยายความสามารถของโมเดลหลากภาษา โดยการขยาย vocabulary ของโมเดลหลากภาษาให้มีคำศัพท์ที่มาจากแบบจำลองภาษาไทยด้วย สามารถใช้คำสั่ง `union` ในการขยาย vocabulary ของโมเดลหลากภาษาได้ดังนี้

```python
multilingual_vocab = {'hello', 'สวัสดี', '你好', 'สวัสดี', 'สวัสดี', 'สวัสดี'}
thai_vocab = {'สวัสดี', 'ขอบคุณ'}
larger_vocab = multilingual_vocab.union(thai_vocab) 
print(larger_vocab)
```
หลังจากรันโค้ดแล้วลอง `print` ค่าที่ปรากฏอยู่ในตัวแปรจะได้ผลดังนี้
```python
{'สวัสดี', 'hello', 'ขอบคุณ', '你好'}
```
คำสั่ง `union` คืนค่าเป็นเซ็ตใหม่ขึ้นมาต่างหาก แยกต่างหากจาก `multilingual_vocab` และ `thai_vocab` ที่เราใช้ในการเรียกคำสั่ง เช่นเดียวกับการใช้คำสั่ง `intersection`

ข้อสังเกตอีกอย่างหนึ่งคือ สมาชิกของเซ็ตที่คืนมาจากการใช้คำสั่ง `union` จะไม่เรียงลำดับตามพจนานุกรม หรือเรียงลำดับใด ๆ เลย แต่เราสามารถใช้ `sorted()` ในการเรียงลำดับสมาชิกของเซ็ตได้ ดังตัวอย่างต่อไปนี้

```python
multilingual_vocab = {'hello', 'สวัสดี', '你好', 'สวัสดี', 'สวัสดี', 'สวัสดี'}
thai_vocab = {'สวัสดี', 'ขอบคุณ'}
larger_vocab = multilingual_vocab.union(thai_vocab)
print(sorted(larger_vocab))
```
output ที่จะปรากฏบนหน้าจอ คือ 
```python
['hello', 'ขอบคุณ', 'สวัสดี', '你好']
```
สังเกตว่าผลที่ได้จะออกมาเป็นลิสต์ ซึ่งเป็นพฤติกรรมที่สมเหตุสมผลของคำสั่ง `sorted` เนื่องจากเราจำเป็นต้องใช้โครงสร้างข้อมูลที่มีการเก็บลำดับของสมาชิกแต่ละตัว 

#### ตัวอย่าง: การลบกันของเซ็ต
สมมติเราต้องการทราบว่า `thai_vocab` มีคำศัพท์ภาษาไทยมากกว่า `multilingual_vocab` กี่คำ สามารถใช้คำสั่ง `difference` ในการหาคำศัพท์ที่มีใน `thai_vocab` แต่ไม่มีใน `multilingual_vocab` ได้ดังนี้

```python
multilingual_vocab = {'hello', 'สวัสดี', '你好', 'สวัสดี', 'สวัสดี', 'สวัสดี'}
thai_vocab = {'สวัสดี', 'ขอบคุณ'}
thai_only_vocab = thai_vocab.difference(multilingual_vocab)
print(thai_only_vocab)
```
หลังจากรันโค้ดแล้วลอง `print` ค่าที่ปรากฏอยู่ในตัวแปรจะได้ผลดังนี้
```python
{'ขอบคุณ'}
```
คำสั่ง `difference` คืนค่าเป็นเซ็ตใหม่ขึ้นมาต่างหาก แยกต่างหากจาก `multilingual_vocab` และ `thai_vocab` ที่เราใช้ในการเรียกคำสั่ง เช่นเดียวกับการใช้คำสั่ง `intersection` และ `union`

### สรุป
เซ็ตในภาษาไพธอนเป็นโครงสร้างข้อมูลที่เหมาะสมกับการเก็บข้อมูลที่ไม่มีการจัดลำดับ และไม่มีการเก็บข้อมูลที่ซ้ำกัน โดยเซ็ตในภาษาไพธอนมีความสามารถในการใช้ set operation ได้ทั้งหมด 3 ตัว คือ intersection union และการลบกันของเซ็ต ในการประมวลผลภาษาธรรมชาติเซ็ตมักถูกใช้ในการเก็บรายการคำศัพท์ หรือเรียกว่า vocabulary 

คำสั่งของเซ็ตในภาษาไพธอน สรุปเป็นตารางได้ดังนี้
| operation | สัญลักษณ์ทางคณิตศาสตร์ | คำสั่งในไพธอน | 
| --- | --- | --- | 
| intersection | A ∩ B | `setA.intersection(setB)` | 
| union | A ∪ B | `setA.union(setB)` | 
| difference | A - B | `setA - setB` หรือ `setA.difference(setB)` | 

ทั้งสามคำสั่งจะคืนค่าออกมาเป็นเซ็ตใหม่แยกต่างหากจาก `setA` และ `setB` ที่เราใช้ในการเรียกคำสั่ง หลังจากเรียกคำสั่ง set operation แล้ว สมาชิกของ `setA` และ `setB` จะไม่เปลี่ยนแปลง



